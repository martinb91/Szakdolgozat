\Chapter{Implementáció}

% TODO: Ide kerülhetnek a konkrét kódrészek.
% TODO: Le lehet írni, hogy mit volt egyszerűbb/komplikáltabb összerakni.
Ebben a fejezetben igyekszem bemutatni néhány izgalmasabb esetet, amelyek vagy a bonyolultságuk miatt érdekesek vagy számomra rengeteg fejtörést okoztak amire elkészültek.

\subsubsection{Fesztivál keresés}
A fesztiválok megkereséséhez használtam a legkomplexebb folyamatot. Amelyben először a felület felől meg vizsgáljuk, hogy melyik keresési paramétereket adta meg a felhasználó, és csak azokat a paramétereket küldjük el a szerveroldalra, amelyeket megadta. Az x és y koordinátát egy google maps API-n keresztül szerzem meg, ahol beírja a felhasználó a kívánt települést, a rendszer pedig már a településhez tartozó koordinátákkal dolgozik tovább. Ha nem ír be semmit, akkor ezek az értékek üresek maradnak és a helytől való távolságot sem érdemes elküldeni a túloldalra. Amint látható a HttpParams objektumnak csak string típusú változókat lehet átadni, így cast-olni kellett karakterlánccá az értékeket. A dolog érdekessége, hogy a Spring oldalon ki lehet venni más típusként is.
A lekérdezésből visszaérkezett adathalmazt leképezzük a modellnek megfelelő formára és a modellekből készült tömbbel tér vissza a metódus a megjelenítési réteghez.

A metódus egyik paraméterét sem kötelező átadni neki, hisz ez egy lekérdezés, jöhet kevesebb információval is kérés. Ha érkezik dátum érték azt Date formátumra kell konvertálnunk és csak ezután hívhatjuk meg a a FestivalService festsByQuery metódusát.

A festsByQuery metódust implementáltam A FestivalServiceImpl osztályban. A függvény paraméter szignatúrája a következő: \texttt{(String style, boolean isFree, Date begin, Date end, Double posX, Double posY, Double maxFromPos)} a visszatérési értéke egy \texttt{FestivalDTO} lista. A rendszert minden egyes lehetséges kombinációra fel kell készíteni, természetesen lesznek olyan lekérdezések, amelyeket többször is meghívhatóak más paraméterrel. Abból ered ez, hogy az ingyenességet nem boolean változóban tárolom, hanem stílusparaméterként.
Ha nem kapunk stílust akkor az alábbi ágba fut a programunk.
\begin{java}
if (!isFree) {
festivals = datesWithoutStyle(begin, end, posX, posY, 
maxFromPos);
} else {
    festivals = datesWithStyle("free", begin, end, posX, posY,
    maxFromPos);
}
\end{java}

Ha a felhasználó nem pipálta be, hogy ingyenes legyen a kiválasztott fesztivál, akkor lekérdezzük az adatbázisból a megadott dátumok szerinti eredményt.
Természetesen itt is előfordulhat, hogy nem adott meg dátumokat. Mind a négy lehetséges esetben már belenyúlunk az adatbázisba. Ha sem a kezdő, sem a végdátuma nincs megadva az intervallumnak amelybe keresünk, akkor mindent visszaadunk ami jelen pillanatban még nem fejeződött be.

\begin{java}
festivalRepository.findByEndDateAfterOrderByBeginDate
(new Date(begin.getTime() - 1));
\end{java}

A fenti kódot használhatjuk, ha ismerjük az intervallum kezdetét, de a végét nem. Az előző esetben is ezt a kódot kell használni csak a pillanatnyi dátummal meghívva.
A kód a \texttt{CrudRepository} kiterjesztésével létrehozott \texttt{FestivalRepository} interfészt hívja meg amelyben ha bizonyos név konvenciókat betartunk, akkor automatikusan legenerálja a Query-t(lekérdezést) számunkra. De mint látható ez meglehetősen hosszú metódus neveket szül. A függvény az alábbi paraméterrel azokat adja vissza, amelyiket fesztiválokat a megadott pillanattól kezdve még érdemes meglátogatni. A -1 érték azért van ott, mert sajnos megvannak a határai az automatikusan generált lekérdezésnek és a <= relációt tudtam kisajtolni belőle, csak a < jelet, így egy egységgel csökkentem és akkor már azt kapjuk vissza amit szeretnénk a program kezdésének időpontja szerint rendezve.

\begin{java}
findByEndDateAfterAndBeginDateBeforeOrderByBeginDate(
new Date(), new Date(end.getTime() + 1));
\end{java}

Ha csak azt adja meg a felhasználónk, hogy melyik időpontig alkalmas neki, akkor a \texttt{FestivalRepository} fenti függvényét érdemes meghívni a megadott paraméterekkel.
Ugyan ez a függvény lesz jó nekünk arra, ha mindkettő dátum benne van a kérésben. Az első paramétert le kell cserélnünk \texttt{new Date(begin.getTime() - 1)}-re, hiszen itt megvan adva a \texttt{begin} érték is.

Ezek után a visszakapott értékekkel meg kell hívni a \texttt{workWithPositions(festivals, posX, posY, maxFromPos)} függvényt a megadott szignatúrával. Ez a függvény a Haversine formula segítségével megvizsgálja a megadott paraméterek alapján az átadott fesztiválokat. Ha nem kaptunk pozíciót akkor vissza adunk mindent, ha csak pozíciót kaptunk, akkor az 5 km-en belülieket adjuk vissza, ha kapunk távolságot és pozíciót, akkor a pozíciótól megadott távolságon belüli fesztiválokat adja vissza.

Elképzelhető az is, hogy kiválasztotta a felhasználó, hogy ingyenes fesztiválok érdeklik, vagy esetleg stílust adott meg. Előfordulhat az is, hogy mindkettőt megadta a felhasználó. Mindhárom esetben a fesztivál keresés részben megadott kód else ágában lefutó \texttt{datesWithStyle} függvényre lesz szükségünk, ami nagyon hasonlóan fog működni mint a \texttt{datesWithoutStyle} csak a lekérdezés összes ágában össze kell kapcsolni a \texttt{FestivalStyle} táblával és onnan lekérdezni azokat amelyiknek a \texttt{style} mezője tartalmazza az átadott értéket, a további műveletek már nem változnak ugyan azokon a függvényhívásokon kell átesnie a visszakapott listának. A teljesség igénye nélkül nézzünk meg egy ilyen lekérdezést JPQL segítségével.

\begin{java}
@Query("select f from Festival f inner join f.styles stl where 
lower(stl.style) like lower(:myStyle) and f.endDate >= :begin
and f.beginDate <= :end order by f.beginDate")
List<Festival> 
findByBeginDateBeforeAndEndDateAfterAndStyleOrderByBeginDate
(@Param("myStyle")String style, @Param("begin")Date begin, 
@Param("end")Date end);
\end{java}

Láthatóan itt a kezdő és a végdátum is érkezik paraméterben a stílus mellett. A változókat a \texttt{@Param} annotáció segítségével tudjuk átadni a \texttt{@Query} számára. A JPQL a kettőspont segítségével ismeri fel a paraméterként kapott változókat. A két táblát összekapcsoljuk és a két stílust összehasonlítjuk, úgy hogy mindkettőnek a karaktereit kisbetűsre cseréljük, mert az SQL érzékeny a változók tartalmában levő kis és nagybetűk közti különbségére. Ezután megnézzük, hogy a lekért intervallum kezdő időpontja kisebb vagy egyenlő-e mint a fesztivál befejező és a végdátuma nagyobb vagy egyenlő mint a fesztivál kezdési időpontja, majd rendezzük a kezdés időpontja szerint. Az így keletkezett listával tér vissza a függvény. A fentebb említett esetben annyi lesz a különbség, hogy milyen paramétert adunk át a \texttt{datesWithStyle} függvénynek, illetve mind kettő átadása esetén meghívjuk a kapott stílussal és kód szinten leszűrjük a free paraméterre. Az elkészült listát visszaadjuk a felületnek.

Később rájöttem, hogy a problémát lehetett volna egy kicsivel konszolidáltabban kezelni. Egy \texttt{QueryBuilder}(lekérdezés építő) osztály létrehozásával. Ahol minden paraméteren végigmenve azokat a paramétereket fűzzük fel a lekérdezésre, amelyek nem null értékkel jönnek. A pozícióval kapcsolatos számításokat, illetve ha jön stílus és ingyenes, akkor azt is kód szinten kell külön kezelni. 

\subsubsection{Stílus hozzáadása}
A front-end-en a legkomolyabb problémát a dinamikusan bővülő és csökkenő stílusok tömbje okozta. Tehát, ha módosítani szeretnénk egy fellépő stílusainak tömbjét(ez a probléma ugyanúgy jelentkezett a fesztiválok esetén), azt bővítéssel vagy csökkentéssel vagy az értékek módosításával tehetem meg. A probléma esetén az elem értékének módosítása irreleváns. Példaként vigyünk fel egy új fellépőt. Az üres fellépő inicializálásához a lenti kódrészletre lesz szükségünk.
\begin{java}
 this.myForm = this._fb.group({
        name: [''],
        id: [0],
        description: [''],
        styles: this._fb.array([])
      });
\end{java}
Az \texttt{\_fb} változó \texttt{FormBuilder} típusú, míg a \texttt{myForm} egy \texttt{FormGroup} típusú változó. A \texttt{FormBuilder} mint a neve mutatja, arra alkalmas, hogy egy űrlap struktúráját definiáljuk a különböző metódusain keresztül. A \texttt{styles} ilyen esetben egy üres tömbként jön létre. Új stílust a tömbhöz az \texttt{addStyle} metódussal adhatunk, amely tovább hívja az \texttt{initStyle} metódust. Új esetében nem jön a \texttt{Style} típusú paraméter, tehát üresen inicializáljuk, a hozzáadott cellát a felületen.
\begin{java}
addStyle(s?: Style) {
    const control = <FormArray>this.myForm.controls['styles'];
    const styleCtrl = this.initStyle(s);
    control.push(styleCtrl);
}
\end{java}
Viszont ha módosításra töltjük be akkor az átvett \texttt{EventModel} objektumban megkapott stílusok alapján inicializálja a rendszer, a HTML fájlban indított for ciklus segítségével. Ilyenkor az \texttt{initStyle} metódus \texttt{if (s) \{ sVal = s; \} } ágába is belefut és ezáltal a visszatérési érték már nem egy érintetlen objektum lesz, hanem az adatbázisból érkező értékekkel lesz feltöltve. Természetesen a grafikusfelületről manuálisan van mód ilyen esetben is új üres stílusokat hozzáadni, majd szerkeszteni ezeket. 
\begin{java}
  initStyle(s?: Style) {
    let sVal = new Style();
    sVal.id=0;
    if (s) { sVal = s; }
    return this._fb.group({
      style: [sVal.style],
      id: [sVal.id]
    })
  }
\end{java}
A törléshez az alábbi metódust használhatjuk. Itt a tömb i-edik elemével csökkentjük a tömböt. A HTML tag tárolja, hogy hányadik elem és innen tudjuk kinyerni az információt a törléshez.
\begin{java}
 removeStyle(i: number) {
    const control = <FormArray>this.myForm.controls['styles'];
    control.removeAt(i);
  }
\end{java}
A lenti kis HTML kódrészlet hivatott arra, hogy átadja az inputokat a \texttt{StyleComponent} részére a megjelenítendő stílus objektumok tulajdonságait. Az első paraméter magát a stílus modellt adja át, míg a második a megjelenítés módját, hogy szerkesztésre adjuk át vagy csak megtekintésre. Ezek a folyamatok szinkronban lesznek a befoglaló kódrésszel, tehát ha változtatom a \texttt{viewForm} értékét kívülről, akkor ezt a \texttt{StyleComponent}-ben is változást idéz elő.
\begin{java}
<div class="panel-body" [formGroupName]="i">
     <app-style [group]="myForm.controls.styles.controls[i]"
     [viewForm]="viewForm"></app-style>
</div>
\end{java}

\subsubsection{Fellépő törlése}
A fellépő törlése az implementálandó feladatok közül egyszerűbbek közé tartozott. Viszont elnéztem az URI-t amit megadtam a back-end-en, így elég sok idő volt mire feloldottam a hibát. Nézzük át a folyamatot: Az Angular oldali \texttt{ArtistService} osztály \texttt{deleteById} metódusának meghívásával indítunk egy HTTP hívást a Spring-hez.

\begin{java}
return this._http.delete(
'${environment.Spring_API_URL}/artists/delete',{ params });
\end{java}

Paraméterként csak az id-t adjuk át, mivel ez alapján már egyértelműen azonosítható az objektum. A túloldalon átvesszük a paramétert \texttt{@RequestParam("id") Integer id} kifejezés segítségével.
Majd meg kell hívni a \texttt{deleteArtistById(id)} metódust az \texttt{ArtistService} típusú \texttt{artistService} objektumon és természetesen az \texttt{id}-t tovább adjuk paraméterként. A \texttt{deleteArtistById} metódust megfigyelve láthatjuk, hogy fel kell szabadítanunk a foglalt erőforrásait. A két típusú erőforrás - más néven olyan adatok az adatbázisban, amelyek hivatkoznak a megadott objektumra - amelyet ki kell törölni mielőtt a fellépőt törölnénk, azok a törlendő adatra hivatkozó koncertek és stílusok. A koncertek és a fesztiválstílusok között nem áll fenn függőség, így mindegy melyiket töröljük előbb. Megfigyelhetjük a következő blokkban, hogy én milyen sorrendben tettem.
\begin{java}
concertRepository.deleteByArtist_Id(id);
musicStyleRepository.
deleteMusicStyleByArtist(artistRepository.findOne(id));
return artistRepository.deleteById(id);
\end{java}
Visszatérek a fellépő törlésének az eredményével, ez egy egész számmal tér vissza, a törölt elemek számával, mivel id alapján töröltük, így ez a szám csak 1 és 0 lehet.

\subsubsection{Új koncert felvitele}
A koncert rögzítéséhez a felületen először be kell jelentkeznünk, ilyenkor láthatóvá válik ez a menüpont. A komponens inicializálásakor betöltjük a fesztiválok listáját és a fellépők listáját a felületre, hogy aki rögzíteni szeretné a koncertet annak már csak össze kelljen kattintgatni. Viszont, ha olyan fellépőhöz vagy fesztiválhoz szeretnénk koncertet felvinni amit még nem tartalmaz a rendszer azt előtte rögzítenünk kell. Miután kiválasztottuk a listából a fellépőt és a fesztivált egy \texttt{DateTimePicker} segítségével kiválaszthatjuk az időpontot is, hogy pontosan mikor lesz a koncert. A koncert felvitele gombra kattintva lefut az \texttt{onSubmit} metódus, amely továbbhívja a \texttt{concertService} \texttt{save} metódusát aminek át kell adni egy ConcertModel-t lementésre. A ConcertModel-be csak az esemény és a fellépő id-ját küldöm, bele lehetett volna pakolni az egész objektumot mind kettő esetén, de nem láttam értelmét. A \texttt{DateTimePicker} segítségével kiválasztott dátum olyan formátum generálódik le amit a Spring nem tud átvenni \texttt{Date}-ként, így újra inicializálom saját magával. Ezután a számunkra megfelelő formátumban, de ugyanazzal az értékkel lesz létrehozva, így már küldhetjük a back-end oldalra. Egy  \texttt{HttpClient} típusú objektum post metódusát megfelelően paraméterezve tehetjük meg.
\begin{java}
this._http.post(
`${environment.Spring_API_URL}/concert/new.json`, concert);
\end{java}
Ezt a kérést az alábbi metódus fogja átvenni.
\begin{java}
@RequestMapping(path="/new.json", method = RequestMethod.POST)
public void addConcert(@RequestBody ConcertDTO concertDTO){
	concertService.addConcert(concertDTO);
}
\end{java}
A  \texttt{@ReqestMapping} annotáció segítségével megadhatjuk, hogy melyik csatornát figyelje a metódusunk, és ha a megadott csatornán jön valami, akkor meghívódik a hozzárendelt metódus. Az újabb verziószámú Springek esetén már bevezették a  \texttt{@PostMapping} annotációt. Az annotációs részt lecserélhetnénk \texttt{@PostMapping("/new.json")} sorra és egyenértékű lenne a jelenlegivel, én a fejlesztői környezet színezése miatt átláthatóbbnak találom a jelenlegit. A \texttt{@RequestBody} annotáció segítségével a bejövő kérés body részét nyerhetjük ki. A DI(Dependency Injection)-ról még nem esett szó. Belelendültem az annotációkba, akkor essen pár szó arról is, hogyan kerülnek a controller objektumokba a service objektumok. A controller egy \texttt{@Autowired} annotáció segítségével a konténertől kérhet egy példányt a bean-ekből. 

De mi is az a konténer? A konténer tárolja és menedzseli a beanek élet ciklusait. A konténer feljegyzi, hogy milyen bean-eket ismer és ezekből tud kiosztani minden osztály számára, amelyik igényi. Tehát a konténer segítségével töltöttük fel a \texttt{concertService} változót egy \texttt{ConcertService} típusú bean-nel, és így már meghívhatjuk a metódusait. Az \texttt{addConcert} metódus lekérdezi id alapján a fesztivált majd a fellépőt és beállítja ezeket a koncert adattagjaiként és végül visszatér a mentett objektummal.

\subsubsection{Fellépő módosítása}
A fellépőnél előfordulhat, hogy módosítani kell, valamelyik adatát, például új stílus irányzatban is kipróbálja magát és egy új stílust kell felvinni. A folyamat nagyon hasonló mint az új felvitele esetén csak itt előre betöltjük a UI-ra a módosítható adatait. A felületről elküldött kérés a front-end \texttt{ArtistService} \texttt{save} metódusát hívja meg. Itt van egy elágazás ami az a alapján szelektálja a beérkezett modellt, hogy  van-e id-ja. Mivel a módosítandó objektum id-ja különbözni fog nullától így ebbe az ágba futunk ilyen esetben és ilyenkor egy PUT(módosító) kérést fogunk intézni a back-end felé. A szokásos úton a controller-en keresztül, ahol nem történik vele semmi, csak továbbhívódik eljutunk az \texttt{ArtistService} \texttt{updateArtist} metódusához. Ilyenkor null értékkel érkezik a picture adattag, mert a képfeltöltésre külön eljárás van, tehát be kell töltenünk az adatbázisban elmentett kép nevét, csak így menthetjük el, különben elveszne a felhasználóhoz tartozó kép. Innentől már nem különbözik az eljárás a mentéstől, ezért nem duplikáljuk a kódot inkább meghívjuk az \texttt{addArtist} metódust, amiben lementjük a fellépőnket. A stílusok változását nehezebb detektálni. 

\subsubsection{Bejelentkezés}

\subsubsection{Képek betöltése}
