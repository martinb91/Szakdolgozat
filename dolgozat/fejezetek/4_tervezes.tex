\Chapter{Tervezés}

% TODO: Adatbázis sémájának a definíciója.

% TODO: Az architektúra bemutatása, hogy hol milyen technológia került felhasználásra. (A szokásos szerver-kliens kialakítás néhány egyedi dologgal.)

% TODO: Az alkalmazás felépítéséről UML ábrák. Minél részletesebben bemutatva, hogy minek kellene majd elkészülnie.

%Konkrétan leírni, hol mit és miért választottam. pl harison

Az alkalmazástervezési fázist megelőzte a technológiai tervezés fázisa. Először a technológiai tervezéssel kezdem a fejezetet a back-end-től a front-end felé.

\section{Technológia}

\subsection{Felhasznált webes technológiák}

Az alkalmazás elkészítéséhez az alábbi technológiák használata mellett döntöttem.

\subsubsection{Back-end}
Mindenképpen Java alapú webes alkalmazást szerettem volna, mert a Java program nyelvet ismertem a legjobban, így ez adott volt. A Java-n belül a Spring Boot keretrendszerre esett a választásom, mert ez egy kompakt és könnyen konfigurálható rendszer. Ekkora méretű webes projektnél, nincs is értelme komplexebb rendszert használni, így én sem tettem. 

Az alkalmazásszerver egy Tomcat szerver, de ez is a keretrendszer része. 

Spring Boot applikációnkat egy Spring Security modullal bővítettem, amely az autentikációért és az autorizációért felelős, tehát  a felhasználók jogosultsági szintjüknek megfelelően férhessenek hozzá az adatokhoz. Azért eset erre a választásom, mert jól illeszkednek egymáshoz.

Maven-t használtam a projekt menedzseléséhez. Ennek segítségével lehet az alkalmazás függőségeit letölteni, és az egyes modulokat menedzselni, illetve a build-elési folyamatot automatizálni. A Gradle egy újabb megoldás erre a problémakörre. Egyiket sem ismertem, de mivel a fejlesztői környezet az alkalmazásomat Maven-nel generálta le, így maradta a Maven-nél. Amúgy valószínűleg a Gradle-t választom erre a célra.

JPA(Java Persistence API)-t használok az adatbázishoz való hozzáféréshez. A JPA rosszabb hatásfokú sok esetben mint a JDBC(Java Database Connectivity), hiszen a JPA is JDBC-re fordul le, tehát itt egy plusz réteg kerül be az alkalmazásunkba, viszont gyorsabb fejlesztést eredményez és átláthatóbb kódokat hozhatunk létre vele ezért esett erre a technológiára a választásom.

A DAO(Data Access Object) és a Java Bean-ek közötti leképezésre saját magam által készített leképező osztályokat terveztem készíteni, de szerencsére találtam egy ModelMapper nevű modult ami megoldja helyettem ezt a dolgot, természetesen előfordulhat, hogy majd kézzel is kell ilyen osztályt definiálnom, ha speciális igények merülnek fel.


\subsubsection{RESTful API}

A két rendszer RESTful API-n keresztül kommunikál egymással. Esetünkben és általánosságban is igaz, hogy itt a két rendszer JSON fájlok cseréjével oldja meg a kommunikációt egy egységes interfészen keresztül.

\subsubsection{Front-end}

Angular keretrendszer segítségével oldottam meg a front-end részt. Azért esett a választásom erre a rendszerre, mert elég népszerű jól dokumentált és egy olyan környezetet biztosítson amivel mindent meglehet oldani. Ez az előnye és a hátránya is, hiszen ha eltérünk az előirányzott fejlesztési elvektől - más megoldást szeretnénk választani - könnyen szélmalomharcot vívhatunk a keretrendszerrel. Ezek okán a legtöbb probléma felmerülése esetén könnyű megoldást találni az internet segítségével.

Kiegészítettem egy Bootstrap modullal, hogy valamivel szebb megjelenést biztosítson a felület. Sajnos nem igazán ismerem a CSS-ben rejlő lehetőségeket, így feltehetőleg a weboldal vizuális megjelenése nem lesz a legszebb, de majd igyekszem valahonnan divatosabb minta fájlokat összevadászni, hogy abban már az általam írt kódból kinyert adatok szebb megjelenítést eredményezzenek.

Szükség lehet egy Google Maps API-ra vagy egy másik térkép API-ra, ahol meg tudom jeleníteni a pozíciókat, hogy egyes helyszínek könnyebben behatárolhatóak legyenek.

%Az alkalmazás szerver oldalon egy Spring Boot alkalmazás lesz, ami JPA-n keresztül fér hozzá az adatbázisunkhoz. Ez kiegészül egy Spring Security modullal, amely az autentikációért és az autorizációért felelős, tehát  a felhasználók jogosultsági szintjüknek megfelelően férhessenek hozzá az adatokhoz. Ez egy RESTful API-n keresztül kommunikál az Angular keretrendszer segítségével elkészült front-enddel.


\subsubsection{Szerver-kliens architektúra}

Hogy könnyebben átlátható legyen ezért készítettem az architektúráról egy általános ábrát (\ref{fig:architecture}. ábra). 
A megvalósuló projektből kliens oldalon ki fog maradni a desktop és a mobil alkalmazás. Míg szerver oldalon az alkalmazás szerverhez nem lesznek forráskódok hozzárendelve, mert a megjelenítendő adatokat REST API-n keresztül kommunikálom a front-end felé, és ott válnak elérhetővé weblap formátumban.

\begin{figure}
\centering
\includegraphics[scale=0.365]{kepek/architecture.jpg}
\caption{Szerver-kliens architektúra}
\label{fig:architecture}
\end{figure}

\section{Az alkalmazás tervezése}

\subsection{ER modell}

ER-modellt használtam ahhoz, hogy szemléltessem az egyedek között fennálló relációkat és láthatóvá tegyem a megtervezett adatbázis architektúrát (\ref{fig:er}., \ref{fig:usEr}. ábra).

\begin{figure}
\centering
\includegraphics[scale=0.6]{kepek/er.jpg}
\caption{Az adatbázis ER diagramja}
\label{fig:er}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=0.6]{kepek/userER.jpg}
\caption{Az adatbázis ER diagramja}
\label{fig:usEr}
\end{figure}

Lesz egy fellépő egyedünk, mivel zenei fesztiválokban gondolkodunk, így ezek zenekarok, vagy zenészek lesznek elsősorban. Egy fellépő több stílusban is játszhat, hisz ha egy zenekar népzenét játszik, az nem zárja ki, hogy ezt ötvözzék rockzenei motívumokkal. Sőt rengeteg előadó játszik több stílusban. A fellépőről tartunk számon egy rövid leírást. És elengedhetetlen, hogy az előadó nevét letároljuk. Az egyedi azonosítót pedig automatikusan generáltatjuk. 

Egy fesztiválkereső alkalmazást készítünk, így nem meglepő, hogy lesz egy fesztivál nevű entitásunk is. És talán ez lesz a legnagyobb komplexitású is. Minden fesztiválnak van egy neve, amely alapján a legkönnyebben azonosítják a rendszer felhasználói. Mivel egy ilyen esemény nem tart általában egész évben, ezért van egy kezdetét és végét jelző dátum. Erre a két időpontra azért is lesz szükségünk, hogy az érdeklő előre tudja  tervezni a programjait, és egyáltalán tudja, hogy nem-e ütközik valami más eseménnyel az általa kiválasztott fesztivál. Egy fesztiválnak is lehet több stílusa akár csak egy zenekarnak. Ahogy fentebb írtam itt nem csak a stílusok férnek bele, hanem egyéb jelzők is. Az ID generálást itt is az adatbázisra bízzuk. A leírás részt azoknak az információknak tartjuk fent, amelyekre nem készítettük fel a rendszerünk, és a marketing szövegeknek is kiváló helyet biztosít. A jegy a fejlesztés első fázisában nem lesz bevezetve, így csak egy hyperlink-et tartalmaz majd a forgalmazó weboldalára és nem külön egyedként, hanem egy oszlopként reprezentálódik az adatbázisban.

Koncert táblában két idegen kulcs lesz megtalálható, mivel ez a tábla kapcsolja össze a fellépőt a fesztivállal és ezáltal megtudjuk azt is, hogy milyen előadók vesznek részt az általunk preferált fesztiválon. Azt is megtudjuk nézni, hogy mikor kezdődik a számunkra érdekes előadás, mert egy kezdés nevű tulajdonságot is bevezettem. Lehetett volna tárolni azt is hogy mikor van vége. Alapvetően ez csak egy kapcsoló tábla, így nem szerettem volna túl bonyolítani, és ha valakit érdekel egy program, akkor úgyis kivárja a végét. Egyedi azonosítója ennek a táblának is lesz, amit itt is az adatbázisra bízunk.

Lesz egy helyszín nevű táblánk, amiben címek pozícióit lehet tárolni. Erre azért lesz szükségünk, hogy le tudjuk tárolni, hogy pontosan hol lesz az esemény, vagy a szállás. Természetesen itt is lesz egyedi azonosító minden rekordunkhoz. Ha az x és az y koordinátát tároljunk, akkor rengeteg dolgot ki tudunk váltani ezzel. Van a földnek egy egységes, minden tudományos intézmény által elfogadott geo koordináta rendszere. Ahol minden pozícióhoz tartozik egy hosszúsági és szélességi fok. Ezzel ki lehet váltani az hogy tároljuk a várost, az utcát, a házszámot, irányítószámot. De akár egy fesztivált szervezhetnek olyan helyre is, ahol ezek nincsenek is, akkor ahhoz egy másik struktúrát kellene bevezetni, amiben helyrajzi számot adunk át. És ha ezt a fesztivál szervező úgy kívánja megadni, hogy például az esemény egy adott csarnokban, vagy kulturális központban lesz, akkor megint egy újabb struktúra kerülne bevezetésre. Ha viszont csak a koordinátákat tároljuk, akkor ezeket valamilyen API-n keresztül, vagy előre mások által legyártott adatbázisból könnyen elérhetjük ezt egy koordináta rendszerbeli pont segítségével. Ha a legismertebb Google nevű cég által készített térkép alkalmazást nézzük, ott az egyes koordinátákhoz, nem csak címeket, de akár éttermeket, boltokat, cégeket és minden egyebet tárolhatunk, sőt ezeket még értékelni is lehet. Egy leírást is tárolunk, itt meg lehet adni extra információkat, hol és hogyan közelíthető meg a megadott pont, illetve amíg nem integráljuk az alkalmazást egy API-hoz vagy egyéb elérhető lehetőségek közül addig magát a címet is itt tároljuk.

A szállásokat is tároljuk az adatbázisunkban. Lesz egy fő nevű oszlopunk amely azt tárolja, hogy a szállás hány személyt képes befogadni, ez egy kisebb baráti társaság esetén lehet érdekes. Az ár tulajdonság egységárat tárol, tehát hogy mennyibe kerül egy éjszaka egy fő részére. Általában vannak egyedi konstrukciók, kedvezmények, de mivel mi nem foglalkozunk a foglalással, ezért csak irányárat mutatunk. Szolgáltatunk egy linket, ahol a foglalást el tudják végezni. Természetesen a szállás nevét is megadjuk. A címét az idegen kulcs segítségével könnyen megkaphatjuk. A leírásban minden egyebet tudunk rögzíteni. Az szállásadó elérhetőségeit is megadjuk az érdeklődök számára. A foglalási linken túl még egy telefonszámot és egy email címet is szolgáltat az alkalmazásunk.

Végül, de nem utolsósorban jönnek a felhasználóink, az alkalmazás regisztráció nélkül is teljes értékű alkalmazást nyújt egy keresni szándékozó felhasználó számára. A regisztrációra csak annak van szüksége, aki fel szeretne vinni az adatbázisba rekordokat. Itt több jogosultság is  felmerülhet. Fesztiválmenedzseri, aki a koncerteket, fesztiválokat viheti fel, ő felelős egy vagy több fesztivál menedzseléséért, a zenekarmenedzser, hasonló mint a fesztivál menedzser csak ő a fellépőkért felel. Adminisztrátori neki mindenhez van jogosultsága ami elérhető az alkalmazásból. Mi csak az adminisztrátori jogot fogjuk kiosztani, illetve az átlag felhasználót. A felhasználó személyes adatai közül az e-mail címét, nevét, születési dátumát és a lakhelyét, valamint a jelszavát tároljuk, amit valamilyen hasító algoritmuson lefuttathatunk előtte. Mint mindig itt is az adatbázisunk generálja az azonosítót.

Az egyedek között fent álló relációk a következőek:
\begin{itemize}
\item A fellépő egy-több kapcsolatban áll a koncerttel. Hiszen egy fellépő több koncerten is felléphet, de egy koncerten csak egy fellépő szokott fellépni. Persze van rá példa, hogy van vendég előadó, de ezek az extrém esetek, amúgy is gyakran meglepetések.
\item A fesztivál és a koncert között is egy-több kapcsolat van. Egyértelműen megállapítható az, hogy egy koncert csak egy fesztiválon lehet megrendezve - hasonló lehet máshol is, de egy fesztiválon több koncert is szokott lenni.
\item A fesztivál és a helyszín között egy-egy kapcsolat áll fent, habár a helyszín akár lehet egy település is. Egy fesztiválhoz egy helyszín tartozhat, és egy helyszínen akár több fesztivál is megszervezhető, de a redundancia elhanyagolható volta miatt elég lesz számunkra az egy-egy kapcsolat. Hisz egy fesztivál terület nem egy pont, hanem pontok halmaza. Lehetséges, hogy ugyanahhoz a helyszínhez több különböző pont is tartozik a térképen, így a redundancia tovább csökken.
\item  A helyszín és a szállás között egy-egy kapcsolat van, hiszen egy szálláshoz csak egy cím tartozhat.
\item A stílusok vagy metaadatok és a előadók között több-több kapcsolat van, de túl sok erőforrás pazarlásnak tartottam egy kapcsoló táblát bevezetni egy stílus miatt amiben semmi más nem tárolódik. Ezzel kapcsolatban több megoldást is számba vettem, ezek közül néhány: JSON vagy valamilyen no-SQL-ben eltárolom, és nem hozok létre a számára új táblát. Egy másik lehetőség egy saját struktúrának a bevezetése, például kettős keresztekkel elválasztva, és ez esetben sem lett volna új táblára szükségünk. Ezek a megoldások valamennyit gyorsíthattak is volna a megoldáson, de természetesen ezt tesztelés után lehetne eldönteni. Az egy-több kapcsolat megvalósításnál maradtam.
\item Az előzőhöz hasonlóan a fesztiválstílusok és a fesztivál között is ilyen a kapcsolat.
\end{itemize}

\subsection{UML osztály diagram}

\begin{figure}
\centering
\includegraphics[scale=0.56]{kepek/uml.png}
\caption{Osztály diagram}
\label{fig:umlclass}
\end{figure}

Az ER segítségével megterveztem az adattárolási modellt és a bean-eket vagy POJO-kat.(\ref{fig:umlclass}. ábra)Én az első kifejezést jobban kedvelem így ilyen módon fogok rájuk gyakrabban hivatkozni. A mellékelt ábrán láthatjuk, ezek hogyan alakultak. Minden POJO osztály tartalmaz egy private üres konstruktort és egy publikusat amelyik minden adattagját tartalmazza kivétel az id-t. Az id generálást a JPA-ra bízzuk, de mivel mindegyik id-m Integer típusú, így minden táblában az első elem az 1-es id-t fogja megkapni majd automatikusan 1-esével növekedni fog, tehát a második a kettes id-t kapja és így tovább. Minden bean osztályhoz fog tartozni egy toString metódus és minden adattaghoz tartozik egy getter és egy setter metódus is.  Ezek az ábrán nem szerepelnek, de léteznek ezek is. Azért nem kerültek bele mert átláthatatlan méretű ábra keletkezett volna. Az adattagok természetesen privátok lesznek, míg az osztályok publikusak. A User táblához tartozik egy Role enumeráció, ami két értéket vehet fel vagy USER vagy ADMIN lesz a rendszer által kezelt felhasználó.

\subsection{Az alkalmazás rétegei}

\subsubsection{Java csomagok struktúrája}

Az MVC fejlesztési elvet követtem, de kibővítettem a Spring-ben szokásos Service és Repository rétegekkel, és a View réteget kidobtam, mert a megjelenítés majd Angular feladat lesz. Egyes rétegekben miket is fogunk tárolni:
\begin{itemize}

\item View: A megjelenítésért felelős része az MVC modellnek, itt találhatóak a képek, a gombok, az űrlapok, ezzel találkozik a felhasználó, tehát maga a felhasználói felület. Én ezt a részét nem fogom használni a Springnek.

\item Model: A model, magyarul modell. Az adatok tárolásáért felelős része a kódnak, a perzisztenciáért is ez a rész felelős. Hasonló struktúrát kell követnie, mint az adatbázisnak. Én ezen a részen mint már említettem a JPA technológiát fogom használni.

\item Contoller: Itt találhatjuk meg az üzleti logikát. Itt történnek meg a számítások, innen jönnek a válaszok a felhasználó felé és innen mennek a kérések a modellhez. A Kontroller a kapocs a Modell és a Nézet (View) között.

\item Service: A Spring-ben szokás bevezetni egy új réteget, ez lesz a Service, ennek segítségével ki fog válni az üzleti logika a Controller-ből, és ezt a funkcióját átveszi a Service. A Contoller innentől forgalomirányítóként fog üzemelni.

\item Repository: Bevezetésre kerül egy Repository réteg is amely azért lesz felelős, hogy a Service réteg részére előbányássza az igényelt adatok az adatbázisból, újat vigyen fel, módosítsa azokat vagy törölje, ha szükséges. 
Tehát az adatlekérdező és adatmanipulációs(CRUD) funkciókat valósítsa meg.
\end{itemize}

\subsubsection{Angular csomagok struktúrája}

Az Angular-nál érdemes MVC szerű logikát használni én is erre törekszem. 

\begin{itemize}

\item Service: Az alkalmazás ezen a rétegen keresztül kommunikál a szerver oldallal, itt jelentős üzleti logika nem jellemzi, mint a back-end oldalon. Főként a kéréseket szokás felépíteni ezen a szinten, tehát itt valósul meg a HTTP kommunikáció.

\item Model: A használt objektumok definícióját adjuk meg itt, és ezekre az objektumokra már le tudjuk képezni a kapott eredményeket.

\item Component:  Az Angular komponensekbe szervezi a legfelső réteget, amelybe tartozik egy ts, egy css, és egy html fájl. A css és a html fájlok adják az oldal megjelenését tehát a View-t. Míg a ts adja logikát, hogy az egyes bekövetkezett eseményekre az adott környezetben milyen válasz reakciót kell adni. A komponensek további komponenseket tartalmazhatnak, amelyek egymással tudnak kommunikálni is.

\end{itemize}

\subsubsection{A teljes struktúra bemutatása}
Készítettem egy ábrát(\ref{fig:mvc}. ábra), hogy a projekt egész szerkezetét egyben lássuk és részletesebben megismerhessük.

\begin{figure}
\centering
\includegraphics[scale=0.47]{kepek/mvc_arch.jpg}
\caption{Csomagok struktúrája}
\label{fig:mvc}
\end{figure}


\subsection{Konkrét funkciók}

\begin{comment}{Ezt itt érdemes részletesebben kifejteni, vagy specifikációs jelleggel, vagy pedig már a konkrét implementációt emlegetve.}
\end{comment}

Lekérdezések: % a címeket formázni. 
\begin{itemize}
\item Az összes fesztivált visszaadó funkció, amely mindezt a kezdés időpontja szerint adja vissza. Ez az alapértelmezett, ha a fesztiválok menüpontra kattintunk.
\item Fesztivál visszaadás Id alapján. Egy fesztivált kiválasztunk, a részleteit, illetve a programját az azonosítója alapján kapjuk vissza. 
\item Kiválasztott stílus alapján megkapjuk azon fesztiválok listáját, amelyek a kategória alá tartoznak.
\item Fesztiválok település alapján, ez megvalósulhat API alapján, illetve amíg az nincs addig az egyed leírásából kinyerhető lesz a helyszín. 
\item Fesztivál koordinátáitól 10 km távolságra eső szállások. Akár lehet megadott távolság is, de a szállás keresést nem szeretném a felhasználóra bízni. Hanem a fesztivál kiválasztásakor ajánl a rendszer a fesztiválhoz közeli szállásokat. De akár ez megvalósulhat önálló funkcióként is, ahol megadott koordinátától, megadott távolságra lévő szállásokat tudunk megkeresni, itt a megadott koordináta lehet a fesztivál, a felhasználó meg kiválaszthatja, hogy milyen távolságon belül keres szállást.
\item Fesztiválok keresése két dátum közötti intervallumban, ha a felhasználó az egyiket üresen hagyja, arra is fel kell készíteni a rendszert.
\item Fesztiválok fellépő alapján listázzuk ki az összes olyan fesztivált, amelyiken fellép a kiválasztott fellépő.
\item Koncertek fellépő alapján, hasonló mint az előző, csak itt a pontos időpont is kiderül, hogy mikor lesz a fellépés, illetve a koncert specifikus részletek. %lehet bevezetek egy új adattagot leírás néven a koncerthez.
\item Koncertek fesztivál alapján:  Kiválasztott fesztivál programja. itt érdemes lehet valamilyen rendezési elvet használni. Napokra bontani, betűrend szerint rendezni, vagy színpad szerint csoportosítani. % ehhez kell egy színpad adattag.
\item Fellépők listázása betűrendben.
\item Fellépők visszaadása név, vagy névrészlet alapján.
\item Az összes olyan fellépő visszaadása amelyiknek a stílusa megegyezik a lekért stílussal. A kérés érkezhet egy hashtag-re kattintásból, de lehetőség lesz stílusra is keresni.
\item Lakóhelytől, vagy egy a felhasználótól bekért pozíciótól megadott távolságon belüli fesztiválok.
\item Összes stílust visszaadó funkció, amely értékkészletből könnyebben tud választani, ha esetleg nem jutna eszébe, vagy nem gondolna az esetleges kategóriákra.
\end{itemize}

Új elemek hozzáadása:
\begin{itemize}
\item Szállások felvitele pozíciójával együtt.
\item Fesztivál felvitele pozíciójával és stílusaival együtt.
\item Koncert felvitele, ami valójában egy fellépő és egy fesztivál összekapcsolása.
\item Zenekar felvitele a stílusaival együtt.
\item Új további stílusok hozzáadása zenekarhoz. Itt esetleg bevezetésre kerülhet egy érték készlet is.
\item Plusz stílusok hozzáadása egy fesztiválhoz.
\end{itemize}

 Elemek törlése:
\begin{itemize}
\item Stílusok törlése. Vonatkozik mind a zenei, mind a fesztivál stílusokra. 
\item Koncert törlése.
\item Fesztivál törlése, itt figyelni kell arra, hogy a törlés előtt fel kell szabadítani minden olyan erőforrást ami függ tőle. Tehát törölni kell a koncertjeit, stílusait és a koncert helyszínt is.
\item Fellépő törlése nem jellemző, ha mégis kell akkor azt meg lehet oldani adatbázis szinten is.
\item Szállás törlésénél is figyelni kell, hogy a hozzátartozó helyszínt is törölni kell vele együtt.
\item Amelyik fesztivál és koncert elmúlt, tehát a befejezés dátumán már az aktuális naptári idő  túlhaladt, azt archiválni kell. Erre a funkcióra elég egy triggert írni. Archiválás megvalósítása megoldható úgy, hogy átmozgatjuk egy másik táblába, vagy egy új változó bevezetésével, és azt hogy elérhető-e elég igazról hamisra állítani. Esetleg a mindent vissza adó függvény csak azt adja vissza amelynek a befejező dátuma nagyobb mint az aktuális dátum.
\end{itemize}
Módosítások:
\begin{itemize}
\item Helyszín módosítása.
\item Stílust nem érdemes módosítani. Jobb megoldás a törölés, és helyette egy másikat felvinni.
\item Fesztivál módosítása Ezen belül meghívható a helyszín módosítás és itt hajtható végre a stílusok törlés vagy új felvitele.
\item Zenekar módosítása. A fesztivál törléséhez hasonlóan itt lehet a stílus törlését is elérni a felületen.
\item Koncert módosítása.
\item Szállás módosítása, beleértve a pozíciójának a módosítását. 
\end{itemize}

\begin{comment}{Az egyes hibalehetőségeket is sorra kellene majd venni!}
\end{comment}

\begin{comment}{Meg kellene nézni, hogy hogy lehetne esetleg még jobban csoportosítani a listaelemekben említett dolgokat, és inkább alpontokba rendezni alcímekkel együtt.}
\end{comment}

\subsection{Struktúra}
