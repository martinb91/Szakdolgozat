\Chapter{Tervezés}

% TODO: Adatbázis sémájának a definíciója.

% TODO: Az architektúra bemutatása, hogy hol milyen technológia került felhasználásra. (A szokásos szerver-kliens kialakítás néhány egyedi dologgal.)

% TODO: Az alkalmazás felépítéséről UML ábrák. Minél részletesebben bemutatva, hogy minek kellene majd elkészülnie.

Az alkalmazástervezési fázist megelőzte a technológiai tervezés fázisa. Először a technológiai tervezéssel kezdem a fejezetet a back-end-től a front-end felé.

\section{Technológia}

\subsection{Felhasznált webes technológiák}

Az alkalmazás elkészítéséhez az alábbi technológiák használata mellett döntöttem.

\subsubsection{Back-end}
Mindenképpen Java alapú webes alkalmazást szerettem volna, mert a Java program nyelvet ismertem a legjobban, így ez adott volt. A Java-n belül a Spring Boot keretrendszerre esett a választásom, mert ez egy kompakt és könnyen konfigurálható rendszer. Ekkora méretű webes projektnél, nincs is értelme komplexebb rendszert használni, így én sem tettem. 

Az alkalmazásszerver egy Tomcat szerver, de ez is a keretrendszer része. 

Spring Boot applikációnkat egy Spring Security modullal bővítettem, amely az autentikációért és az autorizációért felelős, tehát  a felhasználók jogosultsági szintjüknek megfelelően férhessenek hozzá az adatokhoz. Azért eset erre a választásom, mert jól illeszkednek egymáshoz.

Maven-t használtam a projekt menedzseléséhez. Ennek segítségével lehet az alkalmazás függőségeit letölteni, és az egyes modulokat menedzselni, illetve a build-elési folyamatot automatizálni. A Gradle egy újabb megoldás erre a problémakörre. Egyiket sem ismertem, de mivel a fejlesztői környezet az alkalmazásomat Maven-nel generálta le, így maradta a Maven-nél. Amúgy valószínűleg a Gradle-t választom erre a célra.

JPA(Java Persistence API)-t használok az adatbázishoz való hozzáféréshez. A JPA rosszabb hatásfokú sok esetben mint a JDBC(Java Database Connectivity), hiszen a JPA is JDBC-re fordul le, tehát itt egy plusz réteg kerül be az alkalmazásunkba, viszont gyorsabb fejlesztést eredményez és átláthatóbb kódokat hozhatunk létre vele ezért esett erre a technológiára a választásom.

A DAO(Data Access Object) és a Java Bean-ek közötti leképezésre saját magam által készített leképező osztályokat terveztem készíteni, de szerencsére találtam egy ModelMapper nevű modult ami megoldja helyettem ezt a dolgot, természetesen előfordulhat, hogy majd kézzel is kell ilyen osztályt definiálnom, ha speciális igények merülnek fel.

\subsubsection{RESTful API}

A két rendszer RESTful API-n keresztül kommunikál egymással. Esetünkben és általánosságban is igaz, hogy itt a két rendszer JSON fájlok cseréjével oldja meg a kommunikációt egy egységes interfészen keresztül.

\subsubsection{Front-end}

Angular keretrendszer segítségével oldottam meg a front-end részt. Azért esett a választásom erre a rendszerre, mert elég népszerű jól dokumentált és egy olyan környezetet biztosítson amivel mindent meglehet oldani. Ez az előnye és a hátránya is, hiszen ha eltérünk az előirányzott fejlesztési elvektől - más megoldást szeretnénk választani - könnyen szélmalomharcot vívhatunk a keretrendszerrel. Ezek okán a legtöbb probléma felmerülése esetén könnyű megoldást találni az internet segítségével.

Kiegészítettem egy Bootstrap modullal, hogy valamivel szebb megjelenést biztosítson a felület. Sajnos nem igazán ismerem a CSS-ben rejlő lehetőségeket, így feltehetőleg a weboldal vizuális megjelenése nem lesz a legszebb, de majd igyekszem valahonnan divatosabb minta fájlokat összevadászni, hogy abban már az általam írt kódból kinyert adatok szebb megjelenítést eredményezzenek.

Szükség lehet egy Google Maps API-ra vagy egy másik térkép API-ra, ahol meg tudom jeleníteni a pozíciókat, hogy egyes helyszínek könnyebben behatárolhatóak legyenek.

%Az alkalmazás szerver oldalon egy Spring Boot alkalmazás lesz, ami JPA-n keresztül fér hozzá az adatbázisunkhoz. Ez kiegészül egy Spring Security modullal, amely az autentikációért és az autorizációért felelős, tehát  a felhasználók jogosultsági szintjüknek megfelelően férhessenek hozzá az adatokhoz. Ez egy RESTful API-n keresztül kommunikál az Angular keretrendszer segítségével elkészült front-enddel.


\subsubsection{Szerver-kliens architektúra}

Hogy könnyebben átlátható legyen ezért készítettem az architektúráról egy általános ábrát (\ref{fig:architecture}. ábra). 
A megvalósuló projektből kliens oldalon ki fog maradni a desktop és a mobil alkalmazás. Míg szerver oldalon az alkalmazás szerverhez nem lesznek forráskódok hozzárendelve, mert a megjelenítendő adatokat REST API-n keresztül kommunikálom a front-end felé, és ott válnak elérhetővé weblap formátumban.

\begin{figure}
\centering
\includegraphics[scale=0.365]{kepek/architecture.jpg}
\caption{Szerver-kliens architektúra}
\label{fig:architecture}
\end{figure}

\subsection{Fejlesztői környezetek}

A fejlesztéshez a JetBrains termékeit fogom használni. A szerveroldali fejlesztéshez az InteliJ IDEA nevű szoftvert, a front-end-hez pedig a WebStorm-ot. Azért döntöttem mellettük, mert nagyon színvonalas eszközök, sokrétűen támogatják a fejlesztést. 
Ezenkívül a Postman alkalmazást használom a minta kérések beküldéséhez, ezáltal a funkciók teszteléséhez szerver oldalon. 

\section{Az alkalmazás tervezése}

\subsection{ER modell}

ER-modellt használtam ahhoz, hogy szemléltessem az egyedek között fennálló relációkat és láthatóvá tegyem a megtervezett adatbázis architektúrát (\ref{fig:er}., \ref{fig:usEr}. ábra).

\begin{figure}
\centering
\includegraphics[scale=0.6]{kepek/er.jpg}
\caption{Az adatbázis ER diagramja}
\label{fig:er}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=0.6]{kepek/userER.jpg}
\caption{Az adatbázis ER diagramja}
\label{fig:usEr}
\end{figure}

Lesz egy fellépő egyedünk, mivel zenei fesztiválokban gondolkodunk, így ezek zenekarok, vagy zenészek lesznek elsősorban. Egy fellépő több stílusban is játszhat, hisz ha egy zenekar népzenét játszik, az nem zárja ki, hogy ezt ötvözzék rockzenei motívumokkal. Sőt rengeteg előadó játszik több stílusban. A fellépőről tartunk számon egy rövid leírást. És elengedhetetlen, hogy az előadó nevét letároljuk. Az egyedi azonosítót pedig automatikusan generáltatjuk. 

Egy fesztiválkereső alkalmazást készítünk, így nem meglepő, hogy lesz egy fesztivál nevű entitásunk is. És talán ez lesz a legnagyobb komplexitású is. Minden fesztiválnak van egy neve, amely alapján a legkönnyebben azonosítják a rendszer felhasználói. Mivel egy ilyen esemény nem tart általában egész évben, ezért van egy kezdetét és végét jelző dátum. Erre a két időpontra azért is lesz szükségünk, hogy az érdeklő előre tudja  tervezni a programjait, és egyáltalán tudja, hogy nem-e ütközik valami más eseménnyel az általa kiválasztott fesztivál. Egy fesztiválnak is lehet több stílusa akár csak egy zenekarnak. Ahogy fentebb írtam itt nem csak a stílusok férnek bele, hanem egyéb jelzők is. Az ID generálást itt is az adatbázisra bízzuk. A leírás részt azoknak az információknak tartjuk fent, amelyekre nem készítettük fel a rendszerünk, és a marketing szövegeknek is kiváló helyet biztosít. A jegy a fejlesztés első fázisában nem lesz bevezetve, így csak egy hyperlink-et tartalmaz majd a forgalmazó weboldalára és nem külön egyedként, hanem egy oszlopként reprezentálódik az adatbázisban.

Koncert táblában két idegen kulcs lesz megtalálható, mivel ez a tábla kapcsolja össze a fellépőt a fesztivállal és ezáltal megtudjuk azt is, hogy milyen előadók vesznek részt az általunk preferált fesztiválon. Azt is megtudjuk nézni, hogy mikor kezdődik a számunkra érdekes előadás, mert egy kezdés nevű tulajdonságot is bevezettem. Lehetett volna tárolni azt is hogy mikor van vége. Alapvetően ez csak egy kapcsoló tábla, így nem szerettem volna túl bonyolítani, és ha valakit érdekel egy program, akkor úgyis kivárja a végét. Egyedi azonosítója ennek a táblának is lesz, amit itt is az adatbázisra bízunk.

Lesz egy helyszín nevű táblánk, amiben címek pozícióit lehet tárolni. Erre azért lesz szükségünk, hogy le tudjuk tárolni, hogy pontosan hol lesz az esemény, vagy a szállás. Természetesen itt is lesz egyedi azonosító minden rekordunkhoz. Ha az x és az y koordinátát tároljunk, akkor rengeteg dolgot ki tudunk váltani ezzel. Van a földnek egy egységes, minden tudományos intézmény által elfogadott geo koordináta rendszere. Ahol minden pozícióhoz tartozik egy hosszúsági és szélességi fok. Ezzel ki lehet váltani az hogy tároljuk a várost, az utcát, a házszámot, irányítószámot. De akár egy fesztivált szervezhetnek olyan helyre is, ahol ezek nincsenek is, akkor ahhoz egy másik struktúrát kellene bevezetni, amiben helyrajzi számot adunk át. És ha ezt a fesztivál szervező úgy kívánja megadni, hogy például az esemény egy adott csarnokban, vagy kulturális központban lesz, akkor megint egy újabb struktúra kerülne bevezetésre. Ha viszont csak a koordinátákat tároljuk, akkor ezeket valamilyen API-n keresztül, vagy előre mások által legyártott adatbázisból könnyen elérhetjük ezt egy koordináta rendszerbeli pont segítségével. Ha a legismertebb Google nevű cég által készített térkép alkalmazást nézzük, ott az egyes koordinátákhoz, nem csak címeket, de akár éttermeket, boltokat, cégeket és minden egyebet tárolhatunk, sőt ezeket még értékelni is lehet. Egy leírást is tárolunk, itt meg lehet adni extra információkat, hol és hogyan közelíthető meg a megadott pont, illetve amíg nem integráljuk az alkalmazást egy API-hoz vagy egyéb elérhető lehetőségek közül addig magát a címet is itt tároljuk.

A szállásokat is tároljuk az adatbázisunkban. Lesz egy fő nevű oszlopunk amely azt tárolja, hogy a szállás hány személyt képes befogadni, ez egy kisebb baráti társaság esetén lehet érdekes. Az ár tulajdonság egységárat tárol, tehát hogy mennyibe kerül egy éjszaka egy fő részére. Általában vannak egyedi konstrukciók, kedvezmények, de mivel mi nem foglalkozunk a foglalással, ezért csak irányárat mutatunk. Szolgáltatunk egy linket, ahol a foglalást el tudják végezni. Természetesen a szállás nevét is megadjuk. A címét az idegen kulcs segítségével könnyen megkaphatjuk. A leírásban minden egyebet tudunk rögzíteni. Az szállásadó elérhetőségeit is megadjuk az érdeklődök számára. A foglalási linken túl még egy telefonszámot és egy email címet is szolgáltat az alkalmazásunk.

Végül, de nem utolsósorban jönnek a felhasználóink, az alkalmazás regisztráció nélkül is teljes értékű alkalmazást nyújt egy keresni szándékozó felhasználó számára. A regisztrációra csak annak van szüksége, aki fel szeretne vinni az adatbázisba rekordokat. Itt több jogosultság is  felmerülhet. Fesztiválmenedzseri, aki a koncerteket, fesztiválokat viheti fel, ő felelős egy vagy több fesztivál menedzseléséért, a zenekarmenedzser, hasonló mint a fesztivál menedzser csak ő a fellépőkért felel. Adminisztrátori neki mindenhez van jogosultsága ami elérhető az alkalmazásból. Mi csak az adminisztrátori jogot fogjuk kiosztani, illetve az átlag felhasználót. A felhasználó személyes adatai közül az e-mail címét, nevét, születési dátumát és a lakhelyét, valamint a jelszavát tároljuk, amit valamilyen hasító algoritmuson lefuttathatunk előtte. Mint mindig itt is az adatbázisunk generálja az azonosítót.

Az egyedek között fent álló relációk a következőek:
\begin{itemize}
\item A fellépő egy-több kapcsolatban áll a koncerttel. Hiszen egy fellépő több koncerten is felléphet, de egy koncerten csak egy fellépő szokott fellépni. Persze van rá példa, hogy van vendég előadó, de ezek az extrém esetek, amúgy is gyakran meglepetések.
\item A fesztivál és a koncert között is egy-több kapcsolat van. Egyértelműen megállapítható az, hogy egy koncert csak egy fesztiválon lehet megrendezve - hasonló lehet máshol is, de egy fesztiválon több koncert is szokott lenni.
\item A fesztivál és a helyszín között egy-egy kapcsolat áll fent, habár a helyszín akár lehet egy település is. Egy fesztiválhoz egy helyszín tartozhat, és egy helyszínen akár több fesztivál is megszervezhető, de a redundancia elhanyagolható volta miatt elég lesz számunkra az egy-egy kapcsolat. Hisz egy fesztivál terület nem egy pont, hanem pontok halmaza. Lehetséges, hogy ugyanahhoz a helyszínhez több különböző pont is tartozik a térképen, így a redundancia tovább csökken.
\item  A helyszín és a szállás között egy-egy kapcsolat van, hiszen egy szálláshoz csak egy cím tartozhat.
\item A stílusok vagy metaadatok és a előadók között több-több kapcsolat van, de túl sok erőforrás pazarlásnak tartottam egy kapcsoló táblát bevezetni egy stílus miatt amiben semmi más nem tárolódik. Ezzel kapcsolatban több megoldást is számba vettem, ezek közül néhány: JSON vagy valamilyen no-SQL-ben eltárolom, és nem hozok létre a számára új táblát. Egy másik lehetőség egy saját struktúrának a bevezetése, például kettős keresztekkel elválasztva, és ez esetben sem lett volna új táblára szükségünk. Ezek a megoldások valamennyit gyorsíthattak is volna a megoldáson, de természetesen ezt tesztelés után lehetne eldönteni. Az egy-több kapcsolat megvalósításnál maradtam.
\item Az előzőhöz hasonlóan a fesztiválstílusok és a fesztivál között is ilyen a kapcsolat.
\end{itemize}

\subsection{UML osztály diagram}

\begin{figure}
\centering
\includegraphics[scale=0.56]{kepek/uml.png}
\caption{Osztály diagram}
\label{fig:umlclass}
\end{figure}

Az ER segítségével megterveztem az adattárolási modellt és a bean-eket vagy POJO-kat.(\ref{fig:umlclass}. ábra)Én az első kifejezést jobban kedvelem így ilyen módon fogok rájuk gyakrabban hivatkozni. A mellékelt ábrán láthatjuk, ezek hogyan alakultak. Minden POJO osztály tartalmaz egy private üres konstruktort és egy publikusat amelyik minden adattagját tartalmazza kivétel az id-t. Az id generálást a JPA-ra bízzuk, de mivel mindegyik id-m Integer típusú, így minden táblában az első elem az 1-es id-t fogja megkapni majd automatikusan 1-esével növekedni fog, tehát a második a kettes id-t kapja és így tovább. Minden bean osztályhoz fog tartozni egy toString metódus és minden adattaghoz tartozik egy getter és egy setter metódus is.  Ezek az ábrán nem szerepelnek, de léteznek ezek is. Azért nem kerültek bele mert átláthatatlan méretű ábra keletkezett volna. Az adattagok természetesen privátok lesznek, míg az osztályok publikusak. A User táblához tartozik egy Role enumeráció, ami két értéket vehet fel vagy USER vagy ADMIN lesz a rendszer által kezelt felhasználó.

\subsection{Az alkalmazás rétegei}

\subsubsection{Java csomagok struktúrája}

Az MVC fejlesztési elvet követtem, de kibővítettem a Spring-ben szokásos Service és Repository rétegekkel, és a View réteget kidobtam, mert a megjelenítés majd Angular feladat lesz. Egyes rétegekben miket is fogunk tárolni:
\begin{itemize}

\item View: A megjelenítésért felelős része az MVC modellnek, itt találhatóak a képek, a gombok, az űrlapok, ezzel találkozik a felhasználó, tehát maga a felhasználói felület. Én ezt a részét nem fogom használni a Springnek.

\item Model: A model, magyarul modell. Az adatok tárolásáért felelős része a kódnak, a perzisztenciáért is ez a rész felelős. Hasonló struktúrát kell követnie, mint az adatbázisnak. Én ezen a részen mint már említettem a JPA technológiát fogom használni.

\item Contoller: Itt találhatjuk meg az üzleti logikát. Itt történnek meg a számítások, innen jönnek a válaszok a felhasználó felé és innen mennek a kérések a modellhez. A Kontroller a kapocs a Modell és a Nézet (View) között.

\item Service: A Spring-ben szokás bevezetni egy új réteget, ez lesz a Service, ennek segítségével ki fog válni az üzleti logika a Controller-ből, és ezt a funkcióját átveszi a Service. A Contoller innentől forgalomirányítóként fog üzemelni.

\item Repository: Bevezetésre kerül egy Repository réteg is amely azért lesz felelős, hogy a Service réteg részére előbányássza az igényelt adatok az adatbázisból, újat vigyen fel, módosítsa azokat vagy törölje, ha szükséges. 
Tehát az adatlekérdező és adatmanipulációs(CRUD) funkciókat valósítsa meg.
\end{itemize}

\subsubsection{Angular csomagok struktúrája}

Az Angular-nál érdemes MVC szerű logikát használni én is erre törekszem. 

\begin{itemize}

\item Service: Az alkalmazás ezen a rétegen keresztül kommunikál a szerver oldallal, itt jelentős üzleti logika nem jellemzi, mint a back-end oldalon. Főként a kéréseket szokás felépíteni ezen a szinten, tehát itt valósul meg a HTTP kommunikáció.

\item Model: A használt objektumok definícióját adjuk meg itt, és ezekre az objektumokra már le tudjuk képezni a kapott eredményeket.

\item Component:  Az Angular komponensekbe szervezi a legfelső réteget, amelybe tartozik egy ts, egy css, és egy html fájl. A css és a html fájlok adják az oldal megjelenését tehát a View-t. Míg a ts adja logikát, hogy az egyes bekövetkezett eseményekre az adott környezetben milyen válasz reakciót kell adni. A komponensek további komponenseket tartalmazhatnak, amelyek egymással tudnak kommunikálni is.

\end{itemize}

\subsubsection{A teljes struktúra bemutatása}
Készítettem egy ábrát(\ref{fig:mvc}. ábra), hogy a projekt egész szerkezetét egyben lássuk és részletesebben megismerhessük.

\begin{figure}
\centering
\includegraphics[scale=0.47]{kepek/mvc_arch.jpg}
\caption{Csomagok struktúrája}
\label{fig:mvc}
\end{figure}

Az ábrán megfigyelhető, hogy a repository osztályokon keresztül fér hozzá az adatbázishoz a rendszer, természetesen az adatbázis eléréséhez, kell ismernie egy felhasználó név, jelszó párost és egy elérési útvonalat a rendszernek az adatbázishoz, amelyet általában valamilyen környezeti változóban szokás megadni. A repository osztályokban fogjuk megadni az SQL lekérdezéseket, amelyeket gyakran ki sem kell írni, mert a keretrendszer az adatbázis struktúra ismeretében legenerálja azokat metódus neveket és megfogalmazza hozzá a lekérdezést, ha a CRUDRepository-t kiterjeszti az interfészünk . Természetesen ezek a nevek natív SQL-re konvertálódnak a lekérdezés alkalmával. Mivel ritkán fogunk bonyolultabb lekérdezéseket definiálni, így gyakran elegek lesznek, ha pedig bonyolultabb lekérdezést szeretnénk használni, akkor \texttt{ @Query } paraméterként megadhatjuk vagy natív SQL-ként vagy a JPQL lekérdező nyelv segítségével. A JPQL-t használom, mert ennek a szintaxisával jobb barátságot ápol az IntelliJ IDEA, és ad rá kódkiegészítést. A repository-k  lekérdezettek olyan típusokkal amelyek mező szinten definiáltak az adatbázisban vagy entity(bean) típusokkal térhetnek vissza. A módosítás, törlés és új létrehozása is a bean-ekre vonatkozik vagy annak egyes mezőire.

A service rétegben foglalnak helyet a mapper és a service osztályok, interfészek. A serviceket szokás interfészként megadni és létrehozni egy olyan osztályt ami ezeket a szolgáltatásokat implementálja. A service-k metódusai a controllertől kapják a kéréseket és a repository-hoz intézik a saját kéréseiket.  A service osztályokban történik meg a beérkezett adatok feldolgozása és az elvégzendő műveleteket is itt hajtatjuk végre, majd a végrehajtott eredményeket letároljuk és/vagy kommunikáljuk a UI felé a controller segítségével. Általánosságban az is elmondható, hogy a repository felől entity-ket kezel míg a a controller fele Data Transfer Object-eket (továbbiakban DTO). A Mapper osztályra azért lesz szükség, hogy a DTO osztályokat Bean-ekké és a Bean-eket DTO-ká alakítsa oda-vissza.

A kontrollerek azért felelősek, hogy figyeljék, hogy nem-e érkezik a kliens oldalról valamilyen kérés, és ha érkezett, akkor ezt kiszolgálják. Ez a modul állítja össze a kérésekre a válaszokat. Itt DTO formátumban fogadjuk az objektumokat, illetve ilyen formában is továbbítjuk őket a túl oldalra. Mint már a service-nél írtam, a controller a service-hez továbbítja a hálózaton kapott információkat a metódusaik meghívásával. A controller-nél minden metódus másik URI-n érkező kérésekre figyel, de ez triviális.

A túl oldalon is találkozunk a service-kel, itt azért felelnek, hogy a kérést intézzék a back-end felé és a visszakapott választ lekezeljék. A kapott értékek valamilyen modell-re leképezhetőek, így definiálhatunk saját modelleket vagy használhatunk olyanokat is amiket a keretrendszer definiál. Sajátokat fogok készíteni, ezek a DTO-knak a tükörképei lesznek JSON formátumban definiálva, hiszen az Angular ezt az adatstruktúrát kezeli könnyedén. 

A komponensbe már modell formátumban érkeznek az adatok, a komponenstől is érkezhet modellt átadva a kérés a service felé, de a lekérdezéseknél ennél jóval kevesebb információ is elég. Ha az adatokon módosításokat végzünk, akkor természetesen minden releváns adatra szükségünk van és ilyenkor már modellt érdemes átadni a service metódusainak.
A komponens view része megjeleníti a böngésző segítségével a kapott információkat. A class része pedig szolgáltatja a megjelenítendő adatot, olyan formában amilyet a view igényel, illetve a kiváltott eseményeket kezeli, ha extra információra van szüksége, akkor azokat elkéri a service-ken keresztül.

Két típusú esemény van, az egyik amelyiket a felhasználó vált ki azzal, hogy használja a rendszert, ezek a view-n keresztül érkeznek. Vannak a felhasználótól független események is, amelyek akkor is kiváltódnak, ha a felhasználó nem nyúlt a rendszerhez, ezek általában a classban keletkeznek, de akár jöhetnek a  szerver oldalról is.

\subsubsection{Egy példa a struktúrára}

Egy kis példát nézzünk erre a front-end-től az adatbázisig, egy űrlapot kitölt a felhasználó, ha minden mezőt megfelelően kitöltött, és rányom a küldés gombra, akkor az meghívja az egyik service valamelyik metódusát. Ha nem sikerült megfelelően kitölteni akkor jön egy figyelmeztetés a class-tól, hogy mi a gond, apróbb logikát amúgy a View is tárolhat. Előbb-utóbb sikerül mindent megfelelően kitöltenie, akkor már a service réteghez is eljut, ahol egy HTTP kérést intéz a szerverhez, itt az interfész érzékeli, hogy jött valamilyen kérés és megpróbálja leképezni, a kontrollerekre, ha nem sikerül akkor visszautasítja, ha talál olyat amelyikre illeszkedik, akkor a gondjaira bízza a kapott információkat, természetesen ettől még megtagadhatja a kiszolgálást, ha olyan tartományból jön vagy nem azonosította magát a kérelmező fél és a rendszer igényli. A controller tovább hívja a service réteget és átadja neki a DTO objektumot paraméterként. Itt pedig a repository rétegnek hívjuk meg a mentés metódusát. Persze előtte le kell képezni a DTO objektumot bean-né. Ezt megtehetjük mapper osztály segítségével vagy kézzel is. Struktúrától függően ki is hagyhatjuk a DTO objektumokat és ilyenkor már a controller réteg bean-t vesz át. A visszatérési értéket pedig a hívási láncon visszafele elindulva eljuttatjuk a front-endnek, és ha minden rendben ment akkor ezt jelezzük a felhasználó számára, ha nem akkor informáljuk a hiba okáról. 
 
\subsection{Konkrét funkciók}

\begin{comment}{Ezt itt érdemes részletesebben kifejteni, vagy specifikációs jelleggel, vagy pedig már a konkrét implementációt emlegetve.}
\end{comment}

Lekérdezések: % a címeket formázni. 
\begin{itemize}
\item Az összes fesztivált visszaadó funkció, amely mindezt a kezdés időpontja szerint adja vissza, illetve amelyik fesztivál már véget ért azt már nincs értelme visszaadni a felhasználónak. Ez az alapértelmezett, ha a fesztiválok menüpontra kattintunk. A megvalósítása egy egyszerű lekérdezés eredménye lesz az adatbázisból. Mint minden lekérdezés ez is az egész hívási láncon végig fog menni amit a példában is megadtunk. Ahol ez megkerülhető azt külön jelezni fogom.
 
\item Egy konkrét fesztivál visszaadása. Ha egy fesztivált ráklikkeléssel kiválasztunk a felületen és ezáltal több információt szeretnénk róla megtudni. Akkor ez kettő vagy három hívást fog generálni. Megtehetjük azt, hogy átadjuk a fesztivál modelljét a listából a fesztiválrészletek weboldalnak, vagy az id-ja alapján lekérdezzük újra. Én a lekérdezés mellett döntöttem mert a többi lekérdezést így-is úgyis végre kell hajtani és azokat is id alapján fogjuk megtenni. Az egyik ilyen kérés ez esetben a fesztivál közelében lévő szállások lekérdezése, a másik pedig a fesztiválhoz tartozó koncertek listája.   

\item Fesztivál koordinátáitól 10 km távolságon belülre eső szállások. Akár lehetne megadott távolság szerinti keresés, de a szállás keresést nem szeretném a felhasználóra bízni. A fesztivál kiválasztásakor ajánl a rendszer a fesztiválhoz közeli szállásokat, amikor az előző pontban megszeretne tudni több információt egy fesztiválról. A későbbiekben akár ez megvalósulhat önálló funkcióként is, ahol megadott koordinátától, megadott távolságra lévő szállásokat tudunk megkeresni. Ez esetben majd a megadott koordináta lehet a fesztivál, és a felhasználó meg kiválaszthatja majd, hogy milyen távolságon belül szeretne találni, de egyenlőre beégetett távolság lesz megadva.

\item Koncertek fesztivál alapján: Ez a másik lekérdezés lesz amikor egy általunk kiválasztott fesztivál programját betöltöttük. A fesztivál id-ja alapján elkérjük a szerver oldalról azokat a koncerteket, amelyek a megadott fesztiválhoz kapcsolódnak, és kijelezzük a felhasználó számára a koncert kezdés idejét és fellépő nevét. És itt ha a fellépőre kattint, akkor a fellépőről is megtudhat információkat. A későbbiekben valamilyen rendezési elv is bekerülhetne, jelenleg csak egy listaként ömlesztem. De lehetne napokra bontani vagy színpad szerint csoportosítani, ehhez viszont az adatstruktúrába egy színpad elemnek is be kell majd kerülnie, ez a tervezés előző fázisaiból kimaradt.

\item Fesztiválok névrészlet alapján:  Ez azoknak kedvez akik már tudják mit keresnek, csak mondjuk a programját szeretnék majd megtekinteni. Ezt elég lehet csak a front-enden kezelni egy map-peléssel, azokra szűrve, amely fesztiválok nevében megtalálható a megadott névrészlet, ilyen esetben nem kell gombot nyomni a felületen, hanem elég csak azt figyeljük, hogy történt-e változás az inputon, és ha igen akkor újra map-peljük a tömböt.

\item Kiválasztott stílus alapján megkapjuk azon fesztiválok listáját, amelyek a kategória alá tartoznak. Ez kétféleképpen fog megvalósulni. Az egyik a hashtag-re kattintva, leszűri azokat a fesztiválokat, ahol megtalálható a megadott stílus, ekkor nem muszáj elkérni a back-end-től a kellő információkat, elegendő az adott feltételek szerint megcsinálni a leképzést. A másik a részletes keresés esetén, ez majd a következő pontban fejtem ki.

\item Komplex keresés, ez alatt több keresési kritérium szerinti keresést értünk. Az egyes lehetőségeket alább pontokba szedve részletezem: 
\begin{itemize}
\item Meg lehet keresni település alapján, illetve településtől való távolság alapján. Ez úgy fog megvalósulni, ha a rendszer felhasználója megadja a fesztiválkereső modulban a települést, akkor a térkép API-tól elkérjük a hely koordinátáit és majd azokat küldöm be, ha a felhasználó ad meg távolságot is a pozíciótól akkor a távolságot is be küldjük. Ezzel kapcsolatban felmerül egy kérdés, hogyan lesz a koordinátákból km és fordítva. Szerencsére nem én vagyok az első aki ezt a kérdést felteszi, így az internet segítségével gyorsan rátaláltam a Haversine formulára. A módszernek az esetünkben van egy kis hibája, hiszen gömbbel számol, de mint tudjuk a föld geoid. Ez egy Magyarország méretű és természeti adottságú ország esetén jelentős torzulást nem okoz. A formulába behelyettesítve a két x és a két y koordinátát ezzel megkapjuk a távolságukat kilométerben, ha az kisebb mint a megadott távolság, akkor megfelel számunkra, ha nem akkor sajnos nem. Mivel egy település koordináták halmaza, így akkor is alkalmaznunk kell a Haversine algoritmust, ha nem adott meg a felhasználó paramétert ilyen esetben 5 km alatti eredményekre szűrünk. 

\item Fesztiválok keresése két dátum közötti intervallumban, ha a felhasználó az egyiket, vagy mindkettőt üresen hagyja, arra is fel készítjük a rendszert. Mindkettő üresen hagyásának esetén akkor a lekérdezés időpontjában még véget nem ért fesztiválokat adjuk vissza. Ha a felső érték üres és az alsó érték van megadva, akkor a keresés időpontjában még véget nem ért fesztiváloktól a megadott időponting elkezdődötteket adjuk vissza. Ha az felső érték van megadva, akkor a megadott időpontkor már elkezdődötteket adjuk vissza. Ha mind kettő meg van adva, akkor a csak alsó érték és a csak felső érték megadásának a metszetét adjuk vissza.

\item Stílus alapú keresés a fesztiválhoz. A jegyeket nem valósítjuk meg és úgy döntöttem, hogy a stílusoknál jelenítem meg. A \#free paramétert vezettem be a stílusoknál erre az esetre. És mivel innentől ez egy stílus lesz, ezt is a stílusoknál kezelem. Emiatt megint lesz 4 esetünk. Az első, nem pipáljuk be a checkboxban, hogy ingyenes, és nem adunk meg semmilyen stílust, ez esetben a keresést nem érintik ezek a paraméterek. A második, megadjuk hogy ingyenes, ilyenkor azokat a fesztiválokat szelektáljuk le amihez tartozik egy free stílusú címke(hashtag). A harmadik eset, ha csak stílus van megadva. Ugyan az történik mint az előző esetben, csak nem free-vel küldjük be a kérést. Amikor mind kettő megvan adva, akkor pedig a stílussal küldjük be a kérést, és a visszakapott listából még leszűrjük azokat amelynek van free stílusa is és csak azokat adjuk át a felület számára.
\item Az itt felsoroltak kombinációira is fel kell majd készítenünk a programunkat, a felsoroltak alapján méltán kapta a komplex keresés nevet ez a pont.
\end{itemize}

\item Az összes fellépő visszaadása, Fellépők menüpontra kattintva elkérjük az adatbázisban található összes fellépőt, és kilistázzuk ezeket. Hasonló, mint a fesztiváloknál, csak itt nem kell annyi mindenre figyelnünk.

\item Fellépők visszaadása névrészlet alapján és/vagy stílus részlet alapján. Ugyanúgy fog működni, mint a fesztiváloknál a név részlet szerinti keresés, csak itt még egy metódus fog figyelni, hogy nem-e történt változás. 

\item Az összes olyan fellépő visszaadása amelyiknek a stílusa megegyezik a lekért stílussal. Ez akkor következik be, ha hashtag-re kattint a felhasználó, ilyenkor lekérdezzük azokat a stílusokat, amelyek értéke megegyezik a kérttel, mivel a JPA össze is kapcsolja a fellépővel, így már csak annyi a dolgunk, hogy visszaadjuk a stílusokhoz tartozó fellépőket.

\item Fellépő részletei, a fellépő összes részlete elérhetővé válik számunkra, ez ugyan azt a struktúrát követi mint a fesztiváloknál volt, csak ide nem tartoznak szállások, viszont a koncerteket itt is elérhetjük.

\item Koncertek fellépő alapján, itt a pontos időpont is kiderül, hogy mikor lesz a fellépés, egy egyszerű szelektálás a fellépő id-ja alapján. Ez akkor hívódik meg amikor a fellépő részleteit kívánjuk betölteni.

\item Összes stílust visszaadó funkció, amely értékkészletből könnyebben tud választani, ha esetleg nem jutna eszébe, vagy nem gondolna az esetleges kategóriákra. Itt le kell kérdezni az összes stílust és egy szűrést kell végezni, hogy mindegyik csak egyszer szerepeljen a listába. Ez a keresés illetve az új felvitele esetén jöhet jól.
\end{itemize}

Új elemek hozzáadása:
\begin{itemize}
\item Szállás felvitele pozíciójával együtt, itt oda kell figyelni arra, hogy minden olyan mezőt kitöltsön a feltöltő ami a szállás szempontjából releváns, a back-end oldalon pedig fontos a hozzátartozó pozíciót is lementeni, nem elég csak a szállást.

\item Fesztivál felvitele pozíciójával és stílusaival együtt. Miden releváns adatra szükségünk lesz, egyes értékeket validáni is érdemes, ilyen lehet a koordináták értéke. Hiszen ez 180 - -180-ig terjedhet, vagy a fesztivál kezdete ne legyen később mint a vége. Itt a stílusok lementésére is oda kell figyelni, a pozícióján kívül.

\item Zenekar felvitele a stílusaival együtt. A stílusok lementésére oda kell figyelni és arra, hogy a releváns adatokat bekérjük, a felviteleknél a JPA-ra bízzuk az id generálást, mint már azt a fejezetben említettem.

\item Kép felvitele, A front-end-en elkészül egy képfelvivő modul és ezt több helyen is el fogom helyezni. A fesztiváloknál és a fellépőknél mindenképpen, a front-end-en a képfeltöltő service osztályának a feltöltés metódusa mindig azt a path-t hívja meg amit paraméterben megkap, tehát ha a fesztiválét akkor a fesztivál kontrollerének megfelelő metódusát fogja meghívni. A path-nak része az id. A túloldalon aszerint mentjük le ahonnan érkezett. Először módosítjuk a képnevét, valami randomizált dolgot hozzá kell fűzni, hogy ugyanolyan nevű képből akár több is felkerülhessen. Le kell kérdezni id szerint azt az objektumot aminek megkaptuk az id-ját és típusát és annak módosítani a kép adattagját a kép nevére, a képet pedig egy közös mappába mentjük el, ahonnan a neve alapján már könnyen kinyerhető, ami ilyenkor már az egyedi azonosítója lesz.

\item Koncert felvitele, ami valójában egy fellépő és egy fesztivál összekapcsolása.

\item Új további stílusok hozzáadása zenekarhoz. Itt esetleg bevezetésre kerülhet egy érték készlet is.
\item Plusz stílusok hozzáadása egy fesztiválhoz.
\end{itemize}

 Elemek törlése:
\begin{itemize}
\item Stílusok törlése. Vonatkozik mind a zenei, mind a fesztivál stílusokra. 
\item Koncert törlése.
\item Fesztivál törlése, itt figyelni kell arra, hogy a törlés előtt fel kell szabadítani minden olyan erőforrást ami függ tőle. Tehát törölni kell a koncertjeit, stílusait és a koncert helyszínt is.
\item Fellépő törlése nem jellemző, ha mégis kell akkor azt meg lehet oldani adatbázis szinten is.
\item Szállás törlésénél is figyelni kell, hogy a hozzátartozó helyszínt is törölni kell vele együtt.
\item Amelyik fesztivál és koncert elmúlt, tehát a befejezés dátumán már az aktuális naptári idő  túlhaladt, azt archiválni kell. Erre a funkcióra elég egy triggert írni. Archiválás megvalósítása megoldható úgy, hogy átmozgatjuk egy másik táblába, vagy egy új változó bevezetésével, és azt hogy elérhető-e elég igazról hamisra állítani. Esetleg a mindent vissza adó függvény csak azt adja vissza amelynek a befejező dátuma nagyobb mint az aktuális dátum.
\end{itemize}
Módosítások:
\begin{itemize}
\item Helyszín módosítása.
\item Stílust nem érdemes módosítani. Jobb megoldás a törölés, és helyette egy másikat felvinni.
\item Fesztivál módosítása Ezen belül meghívható a helyszín módosítás és itt hajtható végre a stílusok törlés vagy új felvitele.
\item Zenekar módosítása. A fesztivál törléséhez hasonlóan itt lehet a stílus törlését is elérni a felületen.
\item Koncert módosítása.
\item Szállás módosítása, beleértve a pozíciójának a módosítását. 
\end{itemize}

\begin{comment}{Az egyes hibalehetőségeket is sorra kellene majd venni!}
\end{comment}

\begin{comment}{Meg kellene nézni, hogy hogy lehetne esetleg még jobban csoportosítani a listaelemekben említett dolgokat, és inkább alpontokba rendezni alcímekkel együtt.}
\end{comment}

\subsection{Struktúra}
