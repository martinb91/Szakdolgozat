\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{t1enc}
\usepackage{hyperref}
\def\magyarOptions{defaults=hu-min}
\hypersetup{
  colorlinks, linkcolor=DarkBlue
}

% Bevezetés 1-2
% Fesztiválok, szolgáltatások 4-5
% Technológia bemutatása 5
% Alkalmazás funkciói 8
% Alkalmazás felépítése 8
% Implementáció részletezése 6
% Hatékonyság vizsgálata 4
% Összegzés 1-2
% Hivatkozások 2

\begin{document}

\begin{center}
\huge Fesztiválkereső webes alkalmazás
\end{center}

\section*{Bevezetés}

A rendszer segít eligazodni a fesztiválok világában, és az érdeklődőknek eldönteni, hogy melyik fesztiválon szeretne részt venni.

[21]"Fesztivál minden olyan – egy vagy több téma köré szerveződő, rendszeresen megrendezésre kerülő, egy vagy több helyszínen történő, meghirdetett programmal rendelkező kulturális, művészeti, gasztronómiai, sport vagy egyéb – eseménysorozat, melynek célja, hogy közönsége részére kiemelten színvonalas, értékközvetítő, minőségi, ismereteket is bővítő és egyben szórakoztató, szabadidős közösségi élményt nyújtson (Magyar Fesztivál Szövetség, 2009)".
A hazai turizmus jelentős részét a program azon belül a fesztiválturizmus adja.
% TODO: Ezt elég csak a végén fixálni!

\section{Fesztiválokhoz kapcsolódó szolgáltatások}

% TODO: Összeszedni lehetőleg az összes olyan funkciót, amelyik fesztiválokhoz kapcsolható lehet, mint releváns szolgáltatás/funkció!

Én a klasszikus értelembe vett zenei vagy zenei vonatkozású fesztiválokra fókuszálok.
A fesztiválokhoz nagyon változatos és sokrétű funkció csoportok tartoznak, melyeket több szempont alapján kategorizálhatunk. Szedjük ezeket szét többféleképpen, hogy meg tudjuk határozni, hogy mik legyenek a szoftvertermékünk valódi megvalósult funkciói.

A fesztiválozáshoz, mint szolgáltatáshoz közvetlenül és közvetve kapcsolódó funkciók:
Közvetlenül kapcsolódó funkciók: Amelyekért a szolgáltatást igénybe veszi a használója.
Vegyük sorra ezeket: 
\begin{itemize}
\item Fellépők, a legnagyobb vonzereje a szolgáltatásnak, ezeket kellő időben és helyen kell megismertetni a közönséggel. Ide értve nem csak a zenei produkciókat, de egyéb performance-t, és előadásokat, prevenciókat.
\item Élelmiszer és ital, a zenei fesztiválok jelentős része 3-10 napos periódusban gondolkodik. Alapvető szükségletet elégít ki, általában egy ilyen esemény alatt nagyobb összeget költenek erre a kategóriára, mint magára a belépőre, utazásra, szállásra.
\item Egyéb sport, kulturális, szellemi programok, vetélkedők. Technológiai bemutatók kipróbálási lehetőséggel.
\item VIP szolgáltatások, közönségtalálkozók.
\end{itemize}

Közvetve kapcsolódó funkciók: Amelyeket nem érzékel, amikért nem fizetne önmagában, illetve nem kell tudnia a fesztiválozónak, de kényelmetlenül érezné magát, ha nem valósulnának meg az alábbi szolgáltatások.
\begin{itemize}
\item Takarítás, WC használat, esetenként a zuhanyzási és alvási lehetőség.
\item A színpadok, dekorációk, kerítések építése, karbantartása, lebontása.
\item A fellépők oda és haza juttatása zökkenőmentesen.
\item Készletgazdálkodás, promóciók, kérdőívek.
\item Média megjelenés.
\item Elektronikus, internetes hálózat, közvilágítás.
\item Biztonság, az időjárás viszontagságai ellen védelem, értékmegőrzés.
\item Rekreáció, egészségmegőrzés.
\item Fodrász, kozmetikus a feltűnő és kreatív megjelenés érdekében.
\item Véradásért cserében valami ellen szolgáltatás.
\end{itemize}

Melyek azok a szolgáltatások, amelyek érdekelni fogják a felhasználót, szeretne előretudni róla, és ezeket egy információs rendszerben meg lehet jeleníteni: \begin{itemize}
\item Fellépők listája, mint már említettem ez az egyik legfőbb vonzerő.
\item Az extrém nem mindenhol kipróbálható sportolási, technológiai lehetőség.
\item Hasznos lehet a környékbeli étkezők elérhetősége, akár étlapja árakkal. Tudjuk, hogy a fesztiválok a magas áraikról és főleg a gyors kajáikról híresek. Érdemes lehet az olcsóbb, vagy a gasztronómia szerelmeseinek a környező elit éttermekről előre információt nyújtani.
\item Dohányboltok, illetve dohányzás. Magyarországon jelenleg a jogszabályi környezet befolyásolja a dohányáruk vásárlási helyét, erről nyújthat információt egy alkalmazás, és arról is, hogy lehetséges-e dohányozni a fesztiválterületen vagy sem.
\item Szállás, vannak olyan fesztiválok, amelyek sátorhelyet és/vagy faházat biztosítanak a közönségük számára. Emellett megjeleníthetőek a kollégiumok, apartmanok, szállodák.
\item Kutyabarátság, kutya bevihető-e a rendezvényre.
\item Gyerekbarátság, gyermekek bevihetőek-e, esetleg vannak-e számukra külön programok.
\item Jegyek, kell-e fizetnünk a fesztiválra belépésért vagy ingyenesen látogatható. Ha igen, akkor milyen jegytípusok érhetőek el.
\item Strandolási lehetőség. A zenei fesztiválok jelentős része nyáron van és vízközelben, hogy a közönségnek legyen lehetősége védekezni a meleg ellen.
\end{itemize}

Az interneten fellelhető már egypár elterjed Fesztivál/Esemény kereső alkalmazás, vannak hiányosságaik és tartalmaznak frappáns ötleteket is. Vegyünk sorra néhányat:

1. http://www.fesztivalkalauz.hu : Az első dolog amivel a felhasználó találkozik az a felhasználói felület, amelynek körülbelül a felét használta ki a fejlesztő. Jelenleg egy 14"-os kijelzőn nézve ez zavaróan kicsi. Feltehetőleg ez azért is van így, mert nagyjából 10 éves fejlesztés, és akkor még nem volt ekkora kijelző választék - sem méret, sem eszköz tekintetében - amelyeken weboldalakat jelenítettünk meg, így elég volt egy statikus méretre és betűtípusra beállítani a weboldalt. Jelenleg divatosak a reszponzív weboldalak, amelyek igyekeznek kiküszöbölni ezt a problémát.
[1] A reszponzív weboldal (RWD) egy olyan megközelítéssel tervezett weboldal, amelynek a célja az, hogy optimális megjelenést biztosítson - könnyű olvashatóság, egyszerű navigáció a lehető legkevesebb átméretezéssel és görgetéssel - a legkülönfélébb eszközökön (az asztali számítógép monitorjától egészen a mobiltelefonokig).
A viszonylag fejlett fesztiválkereső nekem tetszik, sok mindenre rálehet keresni, könnyen és átláthatóan.
Lehet település, kerület, illetve megye szerint is keresni. Típus és dátum szerinti keresés is támogatott. Sőt módunkban áll a következőhavi eseményeket is lekérdezni egy kattintással, erről ha szeretnénk, hírlevelet is kérhetünk. A szabad szavas kereső, annyira azért mégsem szabad, mert csak a címben keres a leírásban sajnos nem.

2. https://www.utazzitthon.hu/program : Az oldal mint a szlogenje is mondja: "Belföldi szállás, program és látnivaló 1 helyen", szállásokat és programokat közvetít az érdeklődőknek. A felület már reszponzív tervezés eredménye, ennek köszönhetően átlátható és könnyen használható akár mobileszközről is. A keresés nagyon világos, kereshetünk régió, tájegység, város szerint és program, látnivaló típusok alapján. Az adatbázisuk programok tekintetében elég gazdag, amikor megtekintettem közel 8000 programot ajánlottak. Itt jegyet is vásárolhatunk az egyes programokra.

3. http://www.fesztival.eu/: A weboldal régi dizájnnal készült. A keresője nagyjából hasonló funkciókat tükrözött, mint az eddigiekben megjelenő keresési lehetőségek. Sajnos az adatbázisában csak egy fesztivál volt megtalálható, amikor ott jártam, így tesztelni nem volt módom.

4. http://www.fesztivalnaptar.hu : Az iranymagyarorszag.hu által működtetett weboldal. Feltehetően az utazzitthon.hu-hoz hasonlóan a szállások közvetítése a főprofilja, és ezek mellé jönnek be a fesztiválok, koncertek mint kiegészítőszolgáltatások. Szabad szavas kereséssel és kronológiai sorrend szerinti érhetőek el a programok. A szabad szavas kereső viszont keres a leírásban is, ami sokat könnyít a felhasználó számára. A felület nem reszponzív és régebbi stílusú. Nem nagy meglepetés, hogy 100-nál kevesebb esemény programját találjuk meg. Itt jelenik meg egyedül a nemzetköziesítés, a magyaron kívül angolul és németül is elérhetőek a programok, habár a programokhoz tartozó leírások csak magyarul érhetőek el.

5. https://www.programturizmus.hu/ : Az utolsó keresést támogató rendszerhez érkeztünk amit találtam, és szerintem a legletisztultabb felülettel és szolgáltatásokkal. Természetesen modern weboldal lévén, platformtól és kijelző mérettől függetlenül szépen megjelenik bármilyen eszközön. Az oldal nem csak fesztiválokra, hanem szinte minden olyan lehetőséget hivatott bemutatni, ami kimozdítja a fotelból a felületen böngésző felhasználót, ez a hozzáállás a szlogenben is tükröződik - "Ne maradj otthon!". Találunk itt a vásárok, látnivalók, és gasztronómián belül, Kolbásztöltő versenytől, a Kutyakiállításon át a Régiségvásárig mindent. Persze megjelennek a már klasszikusnak mondható szállások is. A keresés a már az előzőekben megszokott lehetőségek szerint lehetséges. Viszont az "Események" mellett megjelenik három új lehetőség is, az egyik az "Ajánlat" menü, a másik az "Érdekesség", ezek valami alapján kitüntetett események, viszont az utolsó talán a legérdekesebb. Ez pedig a koordináták alapján megmutatja, hogy hol is lesznek helyileg az események egy google térképen. A jegyet itt is vásárolhatunk. Ha egy fesztivált részletesebben megnézünk, meglepőmódon a jegyen, a címen és szálláson kívül még a környékbeli étkezési lehetőségeket is tanácsolja számunkra a weboldal.

5+1. http://elmenyem.hu : Az oldal nem rendelkezik fesztiválkereső résszel, ez inkább egy blog. De rengeteg aktualitással, hírekkel szolgál a jövőben megrendezendő eseményekkel kapcsolatban. 

%???Egy mátrixot érdemes lehet-e készíteni az oldalakról, hogy melyik oldalnak, milyen lehetőségei vannak.

Extra lehetőségek, amelyekkel nem éltek az itt feltüntetett weboldalak: 
SZÉP-kártya, és egyéb fizetési lehetőségek feltüntetése.
Gyerek illetve kutyabarát-e a rendezvény. Könnyen megvalósítható, mégis látványos lehetőségeket rejt magában, hiszen egy cumi, vagy egy mancs elhelyezése az esemény mellett vagy alatt, adatbázis szinten pedig csak egy boolean változó bevezetése.
Dohányzásra, alkoholfogyasztásra, korhatárra is lehetne bevezetni hasonló kis ikonokat, ezeket is egyszerű paraméterként fel lehetne szerelni.
Értékmegőrzésre, telefon töltésre van-e lehetőség. 
Ingyenes-e a rendezvény: Ez is könnyen felkeltheti az érdeklődők figyelmét. Itt is alkalmazható lenne a már jól bevált ikonos megoldás.
A nemzetköziesítés is szempont lehet, habár ezek az oldalak elsősorban hazai piacra készültek, amelyek fesztiválok nemzetközi vendégeket várnak, azoknak a marketingprogramja is külföldre pozíciónál, és saját weboldallal is rendelkeznek. Ideértve az árak több valutában való megjelenítését is a leírások szövege mellett.
Közlekedés: Érdemes lehet feltüntetni, magát a fesztivál koordinátáit, mint ezt a programturizmus.hu weboldalon láthattuk, emellett érdemes lehet parkolási lehetőségekről térképen előre informálni az odaérkezőket, egy nagyobb eseményre akár több ezer személyautóval is érkezhetnek. A buszpályaudvarról és vasútállomásról a célhoz eljutást segítő helyi járatok menetrendjét is lehetne mellékelni. Az eseménnyel szerződött taxivállalatok telefonszámait felsorolni. A gyalogos eljutást térkép segítségével megmutatni.
Szállás: Mint láthattuk, majdnem mindegyik weboldal ajánlott szállást hotelekben. De a fesztiválok klasszikus közönsége, az nem szállodákban alszik. Általában sátorban, faházakban, kollégiumokban, vagy épp ahol eléri az álom. Érdemes lenne jelezni a felhasználó felé, hogy lehet-e sátrazni, és ha igen, van-e ennek extra költsége. A kollégiumokat, faházakat is lehetne ilyen módon jelezni.
Időjárás: Ez sajnos nem jósolható hónapokkal előre, de pár héttel a fesztivál kezdete előtt ez is felkerülhetne. Hisz mint tudjuk, ezen események javarészt fedetlen vagy részben fedett helyeken zajlanak.
Visszacsatolás: A legtöbb ilyen eseményt többször megrendezik, vannak olyanok amik már 20-30 éves hagyományra tekintenek vissza. Így az értékelések, mind a szervezők, mind a szolgáltatást igénybe vevők számára hasznos információt nyújtanak.
Étkezés: Amire csak a programturizmus.hu gondolt, és alapvetően egy jó kis kiegészítő szolgáltatás, hisz fiziológiai szükségletet elégít ki.

\section{Technológia}

Spring MVC: 2002-ben hozta létre Rod Johnson. Ingyenesen elérhető és nyílt forráskódú Java alapú keretrendszer. Jelenleg egy Pivotal nevű cég foglalkozik a keretrendszer sorsával. Nagyon népszerű, hazánkban is rengeteg a keretrendszert ismerő fejlesztőt keresnek. Alkalmazási területe sokrétű, banki szektortól a telekommunikációig mindenhol feltűnik.\\

Nyílt forráskód: Elérhető bárki számára és kedvére módosíthatja is. A fősodrású keretrendszer újabb változataiba természetesen csak azok a módosítások kerülhetnek bele, amelyeket átnézték és arra érdemesnek ítélték. A nyílt forráskód előnye, hogy rengeteg hibát észrevesznek a fejlesztők, hiszen mindenkinek van hozzáférése a kódbázishoz. Nem szabad lebecsülni a nyílt forráskódú projekteket, az informatikában rengeteg ilyen sikeres projekttel találkozunk. Például Unix/Linux rendszerek, melyek nagy vállalati környezetben elengedhetetlenek.\\

A Java webalkalmazások készítéséhez két alapvető irány alakult ki: a Java Enterprise Edition (Java EE) és a Spring Framework. A Java EE az Oracle a Java jelenlegi készítője által támogatott eredeti verzió. Ezt korábban a Sun Microsystems készítette, melyet felvásárolt az Oracle Corporation 7,4 milliárd dollárért 2009-ben. Mind a kettő moduláris felépítésű, és funkcionalitását tekintve nagyon hasonló modulok jelennek meg. Megtehetjük, hogy az egyiket választjuk vagy a másikat, de akár kombinálhatjuk is őket.\\

[2]A számítógép-programozásban a dependency injection egy technika, aminek lényege, hogy egy objektum más objektumok függőségeit követeli. A függőség objektum szolgáltatást nyújt, az injekció pedig a függőség átadása a függő objektumnak, a kliensnek. A szolgáltatás a kliens állapotának része.[3] A minta alapkövetelménye a szolgáltatás kliensnek való átadása ahelyett, hogy a szolgáltató objektumot a kliens hozná létre.

A szolgáltató osztály szempontjából ez azt jelenti, hogy a kliens nem hívhat rajta konstruktort, vagy statikus metódust. Paramétereit más osztályoktól kapja, azok állítják be. A függőséget előállítja valaki más, például a kontextus vagy a konténer problémája lesz.

A minta célja, hogy annyira leválassza a szolgáltató objektumot a kliensről, hogy ha kicserélik, akkor ne kelljen módosítani a klienst.

[6] A kontroll megfordítása (angolul inversion of control, röviden IoC) főleg objektumorientált programozási nyelvekben használt technika a komponensek összeillesztésére, konfigurálására és kezelésére.

A technika lényege, hogy a komponenskezelést (pl. létrehozást, példányosítást, paraméterezést, megszüntetést, metódus hívás) kiemeljük a programkódból, és általában egy külső keretrendszerre bízzuk, mint pl. a Spring.

A dependency injection a vezérlés megfordításának egyik formája. Ahelyett, hogy az alacsony szintű kód hívná a magas szintűt, a magas szintű fogadja az alacsony szintűt, amit hívhat. Ez megfordítja a procedurális programozás szokásos vezérlési mintáját.

Ahogy a vezérlés megfordításának többi formája, a dependency injection alkalmazza a felelősség megfordításának elvét. A kliens külső kódnak delegálja függőségeinek létrehozását az injektornak, amit azonban nem hívhat.[4] Fordítva, az injektor hívja a klienst, és adja át neki az objektumot. A kliensnek nem kell tudnia, hogyan kell létrehozni a szolgáltatót, és nem kell tudnia az injektor kódról sem. Csak a szolgáltató interfészét kell ismernie, mert ez definiálja, hogyan hívhatja meg a szolgáltatásokat. Ez elkülöníti egymástól a létrehozás és a használat felelősségét.

A kliens három különböző módon fogadhatja a szolgáltatásokat: szetter, interfész és konstruktor alapú injekcióban. Mind a három esetben egy már a heap-ben élő objektumot adunk át. A szetter és a konstruktor injekció abban különbözik, hogy mikor lehet őket használni. Ezektől az interfész alapú injekció abban különbözik, hogy a szolgáltató objektum ellenőrizheti injekcióját. Mindezek megkövetelik, hogy egy külön kód, az injektor hozza létre a kapcsolatot a másik két elem között.[5]

ORM: Object-relational mapping, egy olyan megközelítése az adattárolásnak ami szerint az objektumorientált programozási nyelvekben az objektumok átalakíthatóak a táblázat soraivá.

[7] Perzisztencia: A perzisztencia szót az informatikában olyan adatra használjuk, mely túléli az őt létrehozó folyamatot. 

[7] JPA: A Java perzisztenciát hasonlóképpen definiálhatjuk, csak ez esetben arról van szó, hogy a tárolás a Java programozási nyelv segítségével történik. Legtöbb esetben az adat nagy része főként relációs adatbázisokban tárolódik, melyekhez sokféle módon hozzáférhetünk a Java programból – ezen módok közül egy a JPA.

[8] A Java Database Connectivity, röviden JDBC egy API a Java programozási nyelvhez, amely az adatbázishozzáférést támogatja. A JDBC definiálja az adatbázisok lekérdezéséhez és módosításához szükséges osztályokat és metódusokat. A relációs adatmodellhez igazodik.

Spring Boot: egy relatíve új Springre épülő keretrendszer, mely rengeteg konfigurálási feladatot levesz a programozó válláról és magában a keretrendszerben még egy Tomcat szerver is van, melynek segítségével képes létre hozni egy belső futtató környezetet. Természetesen az alapbeállítások megváltoztathatóak, de már egy kezdő projekt is egy valódi webalkalmazást reprezentál. Nem kell hozzá mélyen ismerni a Spring-et, és összeválogathatóak bele ugyanúgy a Spring modulok. \\

Web-szolgáltatás és web-applikáció közötti különbség: Webservice az, ami XML, JSON, vagy bármilyen jól strukturált választ tud adni egy kérésre (request), amely egy klienstől érkezik, ezek érkezhetnek bármilyen applikációból, akár egy iOS alapú vagy android alapú eszköz alkalmazásától is. Míg egy Webapplication egy honlapon adja vissza a lekérések eredményeit. A web-applikáció is a web-szolgáltatásokon keresztül szerzi meg az adatokat, amiket meg kell jelenítenie. A webszolgáltatások általában egy vagy több adatbázishoz is csatlakoznak, ez nem kritérium, de jellemzően igényelnek adattárolást.\\

Maven: Minden Maven projekthez tartozik egy \texttt{pom.xml} nevű fájl, melyben tartalmaz egy listát a külső függőségeiről, amikre szüksége van a projektnek ahhoz, hogy leforduljon. A Maven ennek a fájlnak segítségével megtalálja ezeket és letölti és a helyére is másolja, így ezeket a műveleteket nem nekünk kell kézzel elvégeznünk.\\

MVC modell:\\

-View: A megjelenítésért felelős része a modellnek, itt találhatóak a képek, a gombok, az űrlapok, ezzel találkozik a felhasználó. Én ezt a részét nem fogom használni a Springnek. egy RESTful API-n fogunk a világháló felé kommunikálni JSON formátumban.\\

-Model: A model, magyarul modell. Az adatok tárolásáért felelős része a kódnak, a perzisztenciáért is ez a rész felelős. Hasonló struktúrát kell követnie, mint az adatbázisnak. Én itt JPA-t és JDBC-t fogok használni. A JPA a perzisztenciáért fog felelni, míg a JDBC az adatbázishoz kapcsolódásért, az adatok törléséért, módosításáért, felviteléért és lekérdezéséért.\\

-Contoller: Itt találhatjuk meg az üzleti logikát. Itt történnek meg a számítások, innen jönnek a válaszok a felhasználó felé és innen mennek a kérések a modellhez. A Kontroller a kapocs a Modell és a Nézet (View) között.\\

-Service: A Spring-ben szokás bevezetni egy új réteget, ez lesz a Service, ennek segítségével ki fog válni az üzleti logika a Controller-ből, és ezt a funkcióját átveszi a Service. A Contoller innentől forgalomirányítóként fog üzemelni.

Annotációk a Springben: Minden osztályban feltűnnek az annotációk. Melyek a keretrendszernek szóló üzenetek, ezek alapján tudja eldönteni a Spring, hogy miként bánjon az egyes osztályokkal, metódusokkal, adattagokkal.\\

Bean: Java komponensek, melyekből bármikor kérhetünk egy példányt a konténertől.

Konténer: A konténer tárolja és menedzseli a bean-ek - magyarul babok - élet ciklusait.

[9] \texttt{@Bean} Explicit módon adhatjuk meg vele a bean-eket a konténer számára.

\texttt{@Component} A komponensek is bean-ek csak ezeket automatikusan konfigurálja a keretrendszer. A Komponenseknek két válfaja van a \texttt{@Service} és a \texttt{@Repository}. A \texttt{@ComponentScan} annotációban megadott ösvényeket végigjárva keresi meg azokat az osztályokat, amelyeknek a definíciójában megtalálható valamelyik komponens típus.

\texttt{@Configuration} A bean leírások információforrása.

\texttt{@EnableAutoConfiguration} Automatikus konfigurálás engedélyezése, ez az annotáció szól a Spring keretrendszernek, hogy amit tud azt állítson be magától, az alapértelmezett beállításokkal, és generálja le az ehhez kellő babokat.

\texttt{@ComponentScan} A konténernek megmondja, hogy melyik csomagokba vizsgálja meg, hogy bean-e vagy sem, ha bean akkor azt feljegyzi, hisz akkor úgy is kell kezelnie  a konténernek. Ha valamelyik osztály kér egy példányt egy bean-ből, akkor csak a konténerben beregisztráltak közül tudunk kiosztani számára. Megadási módja, ha elég csak az a csomag amiben a @ComponentScan-nel annotált osztály elhelyezkedik, akkor nem kell paramétert megadni neki. Viszont, ha ez nem elég számunkra, akkor paraméterezni kell. A paraméterezés ilyen módon történik:
\begin{verbatim}
@ComponentScan(\{"hu.egyik", "hu.masik"\})
\end{verbatim}
tehát zárójelen belül, ha többet szeretnénk felsorolni, akkor kapcsos zárójelen belül, elemenként idézőjelek között felsorolva a csomagok nevét, és vesszővel el választva. Természetesen csak azokat az osztályokat találja meg, amelyik jelzi a konténer számára, hogy ő egy bean, pl.: @Component. \\

\texttt{@EnableAutoConfiguration}: Mindent állítson be magától a keretrendszer, amit csak tud.

\texttt{@Controller}: Controllerrel annotált osztály esetén @Requestmapping egy statikus file nevével tér vissza. (pl JSP vagy HTML file nevével.)

\texttt{@Service}: Jelzi a konténer számára, hogy ő a @Service réteghez tartozik, valami kalkulációt végezni fog.

\texttt{@RestContoller}:
Jelzi a konténer felé, hogy innen érkezhetnek kérések, illetve itt tudjuk fogadni ezeket. És mint a neve is mutatja REST API segítségével. RestContoller elég nagy szabadság fokot biztosít, hisz szinte minden féle struktúrában adhatunk választ és fogadhatunk kérést, hisz ezeket értelmezni tudja. Tipikusan JSON-t fogunk használni, de lehetőség lenne akár XML, HTML választ is adni, a népszerűbb technológiákat kiemelve, de akár egyszerű konstans szöveget is. Tehát ennek az annotációnak a segítségével tudja a Spring, hogy ezzel az osztállyal lehet kommunikálni, ami azt jelenti, hogy tud küldeni és fogadni is adatot.

\texttt{@RequestMapping}:
A ReqestMapping annotáció segítségével megadhatjuk, hogy melyik csatornát figyelje a metódusunk, és ha a megadott csatornán jön valami, akkor meghívódik a hozzárendelt metódus.  A megadás módja \texttt{@ReqestMapping("/")}, tehát az annotáció után zárójelben, dupla idézőjelek között adjuk meg, hogy a honnan érkező kéréseket figyelje, a példában beállított a gyökércsatornán érkező kéréseket figyeli. (de ha /kiscica-t adok meg, akkor azokat fogja figyelni, ami azon a "kiscica" csatornán jön.)

DevTools Maven-ben arra használható, hogy ne kelljen minden módosítás után újrafordítanunk, hanem ha megváltozott a forráskód akkor megteszi helyettünk az IDE.

\subsection{Spring Bean Scope}

A Spring Babok életciklusai.
Singleton: Csak egyetlen példány jön létre belőle. Ez a Springben az alapértelmezett, ha létrejön egy osztály az singleton lesz, ha másként nem rendelkezünk.(például: @RestContoller)
Prototype: Minden egyes alkalommal új példány készül.
Request: Mindenegyes HTTP lekérdezéssel új példányt készül belőle.
Session: Egy Session-höz kötjük a bean-t, a klasszikus példa erre a bevásárlókocsi a webáruházaknál, a kocsiba pakolt termékek addig maradnak amíg a felhasználó ki nem lép a böngészőből, vagy ki nem jelentkezik a weboldalról, így nem kell egy weblap frissítés után újra belepakolni a termékeket amiket meg szeretnénk vásárolni.

Az életciklusok megadásához a \texttt{@Scope} annotáció használatos, zárójelben idéző jelek között megadva a típust, például \texttt{@Scope("prototype")}.

\textit{@Autowired}

A Dependency Injection használatához van erre szükségünk. A keretrendszer aszerint injektálja a Bean-t amilyen a típusánál be van állítva, ha singleton akkor mindig ugyan azt az egyet adja át minden kérés esetén, ha prototype akkor minden egyes alakalommal új példányt ad át és így tovább.
3 fajta megadási mód létezik, az adattag felett megadjuk és ez esetben, ha létrejön az objektum akkor a keretrendszer beleinjektálja az objektumot, amely ebben az esetben egy osztály szintű változó (static). Nehezen tesztelhető ez a fajta megadás.

A második mód a setter alapú megadási mód. Itt létrehozunk a változóhoz egy setter-t és a felett adjuk meg az annotációt.

Az utolsó verzió a konstruktor alapú, itt a konstruktor felett adjuk meg, a már jól ismert \texttt{@Autowired} annotációt.

\section{Az alkalmazás funkciói}

Az eddigiek alapján meg kell határozni, hogy miket szeretnénk, ha megvalósítana az alkalmazásunk, miben lesz más vagy jobb mint a többi a piacon fellelhető alkalmazás. Én igyekszem két új aspektust bevezetni, amelyeket ott nem, vagy nem egészen így alkalmaztak. Az egyik a fellépő alapú szemlélet. Szeretném, ha nemcsak a fesztiválról tudnánk meg többet, hanem az ott fellépő zenekarokról is érhetnénk el információkat. Ha nem ismerem őket, akkor rákattintva megtudhatok róluk pár információt, illetve az oldalra felvitt fesztiválok alapján a turné állomásokat. A másik aspektus a kulcsszavak bevezetése mint fesztivál, mint fellépő oldalon. Hasonlóval találkozhattunk egy-két általam is bemutatott oldalon. Amilyen paraméterek számításba jöhetnek: zenei stílusok, fesztivál stílusok, sátrazási lehetőség, kutyabarát. A divatos nevén a hashtag-ek.
[22]A „hashtag” a metaadat egyik formája, amely egy szóból vagy kifejezésből áll, amely elé hash jelet (\#) tesznek. A hashtagek-et gyakran használják a közösségi hálókon, hogy azonosítsák, kategorizálják az érdeklődési köröket, „topikokat”, illetve megkönnyítsék a kulcsszavak szerinti kutatást.
Adatbázis és program szinten stílusnak neveztem el, de talán ez egy kicsit tágabb fogalom.

ER-modellt használtam ahhoz, hogy szemléltessem az egyedek között fennálló relációkat és láthatóvá tegyem a megtervezett adatbázis architektúrát:
---------
|		|
|	kép	|
|		|
---------
Lesz egy fellépő egyedünk, mivel zenei fesztiválokban gondolkodunk, így ezek zenekarok, vagy zenészek lesznek elsősorban. Egy fellépő több stílusban is játszhat, hisz ha egy zenekar népzenét játszik, az nem zárja ki, hogy ezt ötvözzék, rockzenei motívumokkal. Sőt rengeteg előadó játszik kevert zenét. A fellépőről tartunk számon egy rövid leírást. És elengedhetetlen, hogy az előadó nevét le ne tároljuk. Az egyedi azonosítót pedig automatikusan generáltatjuk. 

Egy fesztiválkereső alkalmazást készítünk, így nem meglepő, hogy lesz egy ilyen nevű entitásunk is. És talán ez lesz a legnagyobb komplexitású is. Minden fesztiválnak van egy neve, amely alapján a legkönnyebben azonosítják a rendszer felhasználói. Mivel egy ilyen esemény nem tart általában egész évben, ezért van egy kezdetét és végét jelző dátum. Erre a két időpontra azért is lesz szükségünk, hogy az érdeklő előre tudja  tervezni a programjait, és egyáltalán tudja, hogy nem-e ütközik valami más eseménnyel az általa kiválasztott fesztivál. Egy fesztiválnak is lehet több stílusa akár csak egy zenekarnak. Ahogy fentebb írtam itt nem csak a stílusok férnek bele, hanem egyéb jelzők is. Az ID generálást itt is az adatbázisra bízzuk. A leírás részt azoknak az információknak tartjuk fent, amelyekre nem készítettük fel a rendszerünk, és a marketing szövegeknek is kiváló helyet biztosít. A jegy a fejlesztés első fázisában nem lesz bevezetve, így csak egy hyperlink-et tartalmaz majd a forgalmazó weboldalára és nem külön egyedként, hanem egy oszlopként reprezentálódik az adatbázisban.

Koncert táblában két idegen kulcs lesz megtalálható, mivel ez a tábla kapcsolja össze a fellépőt a fesztivállal és ezáltal megtudjuk azt is, hogy milyen előadók vesznek részt az általunk preferált fesztiválon. Azt is megtudjuk nézni, hogy mikor kezdődik a számunkra érdekes előadás, mert egy kezdés nevű tulajdonságot is bevezettem. Lehetett volna tárolni azt is hogy mikor van vége. Alapvetően ez csak egy kapcsoló tábla, így nem szerettem volna túl bonyolítani, és ha valakit érdekel egy program, akkor úgyis kivárja a végét. Egyedi azonosítója ennek a táblának is lesz, amit itt is az adatbázisra bízunk.

Lesz egy helyszín nevű táblánk, amiben címek pozícióit lehet tárolni. Erre azért lesz szükségünk, hogy le tudjuk tárolni, hogy pontosan hol lesz az esemény, vagy a szállás. Természetesen itt is lesz egyedi azonosító minden rekordunkhoz. Ha az x és az y koordinátát tároljunk, akkor rengeteg dolgot ki tudunk váltani ezzel. Van a földnek egy egységes, minden tudományos intézmény által elfogadott geo koordináta rendszere. Ahol minden pozícióhoz tartozik egy hosszúsági és szélességi fok. Ezzel ki lehet váltani az hogy tároljuk a várost, az utcát, a házszámot, irányítószámot. De akár egy fesztivált szervezhetnek olyan helyre is, ahol ezek nincsenek is, akkor ahhoz egy másik struktúrát kellene bevezetni, amiben helyrajzi számot adunk át. És ha ezt a fesztivál szervező úgy kívánja megadni, hogy például az esemény egy adott csarnokban, vagy kulturális központban lesz, akkor megint egy újabb struktúra kerülne bevezetésre. Ha viszont csak a koordinátákat tároljuk, akkor ezeket valamilyen API-n keresztül, vagy előre mások által legyártott adatbázisból könnyen elérhetjük ezt egy koordináta rendszerbeli pont segítségével. Ha a legismertebb Google nevű cég által készített térkép alkalmazást nézzük, ott az egyes koordinátákhoz, nem csak címeket, de akár éttermeket, boltokat, cégeket és minden egyebet tárolhatunk, sőt ezeket még értékelni is lehet. Egy leírást is tárolunk, itt meg lehet adni extra információkat, hol és hogyan közelíthető meg a megadott pont, illetve amíg nem integráljuk az alkalmazást egy API-hoz vagy egyéb elérhető lehetőségek közül addig magát a címet is itt tároljuk.

A szállásokat is tároljuk az adatbázisunkban. Lesz egy fő nevű oszlopunk amely azt tárolja, hogy a szállás hány személyt képes befogadni, ez egy kisebb baráti társaság esetén lehet érdekes. Az ár tulajdonság egységárat tárol, tehát hogy mennyibe kerül egy éjszaka egy fő részére. Általában vannak egyedi konstrukciók, kedvezmények, de mivel mi nem foglalkozunk a foglalással, ezért csak irányárat mutatunk. Szolgáltatunk egy linket, ahol a foglalást el tudják végezni. Természetesen a szállás nevét is megadjuk. A címét az idegen kulcs segítségével könnyen megkaphatjuk. A leírásban minden egyebet tudunk rögzíteni. Az szállásadó elérhetőségeit is megadjuk az érdeklődök számára. A foglalási linken túl még egy telefonszámot és egy email címet is szolgáltat az alkalmazásunk.

Végül, de nem utolsósorban jönnek a felhasználóink, az alkalmazás regisztráció nélkül is teljes értékű alkalmazást nyújt egy keresni szándékozó felhasználó számára. A regisztrációra csak annak van szüksége, aki fel szeretne vinni az adatbázisba rekordokat. Itt több jogosultság is  felmerülhet. Fesztiválmenedzseri, aki a koncerteket, fesztiválokat viheti fel, ő felelős egy vagy több fesztivál menedzseléséért, a zenekarmenedzser, hasonló mint a fesztivál menedzser csak ő a fellépőkért felel. Adminisztrátori neki mindenhez van jogosultsága ami elérhető az alkalmazásból. Mi csak az adminisztrátori jogot fogjuk kiosztani, illetve az átlag felhasználót. A felhasználó személyes adatai közül az e-mail címét, nevét, születési dátumát és a lakhelyét, valamint a jelszavát tároljuk, amit valamilyen hasító algoritmuson lefuttattatunk előtte. Mint mindig itt is az adatbázisunk generálja az azonosítót.

Az egyedek között fent álló relációk a következőek:
\begin{itemize}
\item A fellépő egy-több kapcsolatban áll a koncerttel. Hiszen egy fellépő több koncerten is felléphet, de egy koncerten csak egy fellépő szokott fellépni. Persze van rá példa, hogy van vendég előadó, de ezek az extrém esetek, amúgy is gyakran meglepetések.
\item A fesztivál és a koncert között is egy-több kapcsolat van. Egyértelműen megállapítható az, hogy egy koncert csak egy fesztiválon lehet megrendezve - hasonló lehet máshol is, de egy fesztiválon több koncert is szokott lenni.
\item A fesztivál és a helyszín között egy-egy kapcsolat áll fent, habár a helyszín akár lehet egy település is. Egy fesztiválhoz egy helyszín tartozhat, és egy helyszínen akár több fesztivál is megszervezhető, de a redundancia elhanyagolható volta miatt elég lesz számunkra az egy-egy kapcsolat. Hisz egy fesztivál terület nem egy pont, hanem pontok halmaza. Lehetséges, hogy ugyanahhoz a helyszínhez több különböző pont is tartozik a térképen, így a redundancia tovább csökken.
\item  A helyszín és a szállás között egy-egy kapcsolat van, hiszen egy szálláshoz csak egy cím tartozhat.
\item A stílusok vagy metaadatok és a előadók között több-több kapcsolat van, de túl sok erőforrás pazarlásnak tartottam egy kapcsoló táblát bevezetni egy stílus miatt amiben semmi más nem tárolódik. Ezzel kapcsolatban több megoldást is számba vettem, ezek közül néhány: JSON vagy valamilyen no-SQL-ben eltárolom, és nem hozok létre a számára új táblát. Egy másik lehetőség egy saját struktúrának a bevezetése, például kettőskeresztekkel elválasztva, és ez esetben sem lett volna új táblára szükségünk. Ezek a megoldások valamennyit gyorsíthattak is volna a megoldáson, de természetesen ezt tesztelés után lehetne eldönteni. Az egy-több kapcsolat megvalósításnál maradtam.
\item Az előzőhöz hasonlóan a fesztiválstílusok és a fesztivál között is ilyen a kapcsolat.
\end{itemize}

Konkrét funkciók:
\begin{itemize}
\item Lekérdezések: % a címeket formázni. 
\item Összes stílust visszaadó funkció, amely értékkészletből könnyebben tud választani, ha esetleg nem jutna eszébe, vagy nem gondolna az esetleges kategóriákra.
\item Az összes fesztivált visszaadó funkció, amely mindezt a kezdés időpontja szerint adja vissza. Ez az alapértelmezett, ha a fesztiválok menüpontra kattintunk.
\item Fesztivál visszaadás Id alapján. Egy fesztivált kiválasztunk, a részleteit, illetve a programját az azonosítója alapján kapjuk vissza. 
\item Kiválasztott stílus alapján megkapjuk azon fesztiválok listáját, amelyek a kategória alá tartoznak.
\item Fesztiválok település alapján, ez megvalósulhat API alapján, illetve amíg az nincs addig az egyed leírásából kinyerhető lesz a helyszín. 
\item Fesztivál koordinátáitól 10 km távolságra eső szállások. Akár lehet megadott távolság is, de a szállás keresést nem szeretném a felhasználóra bízni. Hanem a fesztivál kiválasztásakor ajánl a rendszer a fesztiválhoz közeli szállásokat. De akár ez megvalósulhat önálló funkcióként is, ahol megadott koordinátától, megadott távolságra lévő szállásokat tudunk megkeresni, itt a megadott koordináta lehet a fesztivál, a felhasználó meg kiválaszthatja, hogy milyen távolságon belül keres szállást.
\item Fesztiválok keresése két dátum közötti intervallumban, ha a felhasználó az egyiket üresen hagyja, arra is fel kell készíteni a rendszert.
\item Fesztiválok fellépő alapján listázzuk ki az összes olyan fesztivált, amelyiken fellép a kiválasztott fellépő.
\item Koncertek fellépő alapján, hasonló mint az előző, csak itt a pontos időpont is kiderül, hogy mikor lesz a fellépés, illetve a koncert specifikus részletek. %lehet bevezetek egy új adattagot leírás néven a koncerthez.
\item Koncertek fesztivál alapján:  Kiválasztott fesztivál programja. itt érdemes lehet valamilyen rendezési elvet használni. Napokra bontani, betűrend szerint rendezni, vagy színpad szerint csoportosítani. % ehhez kell egy színpad adattag.
\item Fellépők listázása betűrendben.
\item Fellépők visszaadása név, vagy névrészlet alapján.
\item Az összes olyan fellépő visszaadása amelyiknek a stílusa megegyezik a lekért stílussal. A kérés érkezhet egy hashtag-re kattintásból, de lehetőség lesz stílusra is keresni.
\item Lakóhelytől, vagy egy a felhasználótól bekért pozíciótól megadott távolságon belüli fesztiválok.

\item Új elemek hozzáadása:
\item Szállások felvitele pozíciójával együtt.
\item Fesztivál felvitele pozíciójával és stílusaival együtt.
\item Koncert felvitele, ami valójában egy fellépő és egy fesztivál összekapcsolása.
\item Zenekar felvitele a stílusaival együtt.
\item Új további stílusok hozzáadása zenekarhoz. 
\item Plusz stílusok hozzáadása egy fesztiválhoz.

\item Elemek törlése:
\item Stílusok törlése. Vonatkozik mind a zenei, mind a fesztivál stílusokra. 
\item Koncert törlése.
\item Fesztivál törlése, itt figyelni kell arra, hogy a törlés előtt fel kell szabadítani minden olyan erőforrást ami függ tőle. Tehát törölni kell a koncertjeit, stílusait és a koncert helyszínt is.
\item Fellépő törlése nem jellemző, ha mégis kell akkor azt meg lehet oldani adatbázis szinten is.
\item Szállás törlésénél is figyelni kell, hogy a hozzátartozó helyszínt is törölni kell vele együtt.
\item Amelyik fesztivál és koncert elmúlt, tehát a befejezés dátumán már az aktuális naptári idő  túlhaladt, azt archiválni kell. Erre a funkcióra elég egy triggert írni. Archiválás megvalósítása megoldható úgy, hogy átmozgatjuk egy másik táblába, vagy egy új változó bevezetésével, és azt hogy elérhető-e elég igazról hamisra állítani.

\item Módosítások:
\item Helyszín módosítása.
\item Stílust nem érdemes módosítani. Jobb megoldás a törölés, és helyette egy másikat felvinni.
\item Fesztivál módosítása Ezen belül meghívható a helyszín módosítás és itt hajtható végre a stílusok törlés vagy új felvitele.
\item Zenekar módosítása. A fesztivál törléséhez hasonlóan itt lehet a stílus törlését is elérni a felületen.
\item Koncert módosítása.
\item Szállás módosítása, beleértve a pozíciójának a módosítását. 
\end{itemize}

A rendszer funkciói(back-end):\\
Stílusok felvitele, módosítása (mely értékkészletből, majd hozzá lehet adni a zenekarokhoz, és a fesztiválokhoz)\\
Zenekarok felvitele, módosítása, esetleges archiválása\\
Fesztiválok felvitele, módosítása, a meglévő fesztiválhoz koncert rendelése(fellépő + időpont)\\
A fesztiválokhoz szállások és jegyek felvitele(jövőben ha lesz rá idő.)\\
Zenekarok keresése és listázása név vagy stílus alapján, ugyan ez fesztiválokra is + fesztiváloknál még helyi, regionális keresés is lehetséges.\\
front-end(van backend része is):
A lekérdezett zenekarra rákattintva visszatér a zenekar adataival és a letárolt fellépéseit is megmutatja kronológia vagy relevancia(egyéb is lehet priorítás) szerint.
Fesztiválra kattintva dobja a fellépőket, melyek megtekinthetők hyperlink segítségével.(Azért lehet hasznos, ha esetleg nem ismerné a felhasználó a zenekart, vagy ha kíváncsi, hogy hol lesz még fellépése).

---------------------

Egy alkalmazáson belül lehet látni, hogy egy előadónak hogy néz ki az adott turnéja. Fellépőre lehet majd tudni keresni.

Javaslatokat adni azokra a koncertekre, amelyekre az előző keresése, és részvételek alapján érdemes lehet mennie az illetőnek.

Statisztikákat csinálni az előadók és koncertszervezők felé. Nekik is lehet így akkor ajánlásokat tenni.

Koncertprogram összeállítása. Megoldani, hogy lehessen ellenőrizni azt, hogy egy koncerten minden elterjedt stílus képviseli magát. A cél az lenne, hogy a koncert minél nagyobb érdeklődési kört lefedjen, de azért maradjon egységes a programja.

Lehet majd távolságokat definiálni stílus, és közös koncertek alapján. Arra kell törekedni, hogy a koncert programja ez alapján kiegyensúlyozott legyen majd.

\section{Az alkalmazás felépítése}

\subsection{Backend}

% TODO: Az adatbázis séma részletezése.

A szerver oldali rész részletezése.

\subsection{Frontend}

A kliens oldali rész részletezése.

\section{Implementáció részletezése}

% TODO: Tesztelési módszerről írni pár dolgot. Külön kitérni a library, szerver oldal és a kliens tesztelésére!

- Java library tesztek
- Spring-en keresztül való tesztelés
- Egységtesztek a klienshez (Angular-os részhez)
- Integrációs teszt féle, hogy egészében működik-e a rendszer.

% TODO: Készíteni valamilyen szerkezeti ábrát, hogy az alkalmazás egyes részei hogy kapcsolódnak majd egymáshoz.


Képek feltöltése

- Hogy lehet megoldani, hogy elegánsan nézzen ki a fájlfeltöltéshez a gomb?
- Drag and drop funkciók
- Formátum ellenőrzése (Ne lehessen feltölteni például zip-et vagy exe-t.)
- A képhez fájnév generálása
- Képhez tartozó adatok rögzítése az adatbázisban

\section{Telepítés}

[23] Spring alkalmazást minimum Java 6-os fordítóval lehet lefordítani futtatható alkalmazássá. Én a Spring Boot 1.5.8.RELEASE kiadást használtam. Itt már csak a Java 7-es verziója használható - a 8 vagy újabb ajánlott - fordításra. Én a Java 8-at használtam, amikor belevágtam a fejlesztésbe, akkor még a Java 9 nem volt elérhető. Azóta már megjelent a 9 is, de én nem váltottam verziót. Alapvetően Java 8 specifikus dolgokat sem használtam, a Java 9-cel még nem volt időm megismerkedni.
Maven segítségével töltöttem le azokat a jar fájlokat amelyektől függ az alkalmazásunk. A 3.5.0 verzió volt akkor a legújabb verzió és általam is használt verzió. A Maven 3.5.0 szintén igényli a minimum a Java hetedik verzióját.
A Maven-nek az alábbi csomagokat kell letöltenie: 
spring-boot-starter-web
spring-boot-starter-data-jpa
spring-boot-starter-test
spring-boot-devtools
ojdbc14 % Az adatbázis még nem bíztos hogy oracle lesz, jelenleg H2-van alatta.

[31]A front-end részhez először telepítettem egy NodeJS-et. Az akkor elérhető legfrissebb verziót, amely a 9.2.0 volt. Ez a keretrendszer oldaláról letölthető. Erre azért volt szükségünk, mert ebben található egy npm nevű modul. Az npm vagy Node Package Manager, mint a neve is mutatja csomagok telepítésére és karbantartására való.
Egy csomagot két féle képen lehet installálni az egyik a helyi telepítés és a globális telepítés. Globálisan olyan csomagokat szokás telepíteni amiket többnyire terminálból akarunk futtatni.
Mi az Angular CLI 1.5-öt globálisan telepítettük npm segítségével, hiszen parancssorból szeretnénk indítani majd a szervert.
A következő paranccsal érhetjük ezt el, hogy a legfrissebb verziót telepítse: npm install -g @angular/cli
Elvileg visszafelé kompatibilis a rendszer, tehát ha a legújabb globális verzió van fent a gépen akkor a régebbi vagy azonos verziószámú projektet képes lesz futtatni. Én Angular 5.0.0-ás verziószámú projektet futtattam benne, és minden gond nélkül elindult.

\section{Hatékonyság vizsgálata}

% TODO: Megnézni, hogy az egyes lekérdezések mennyi idő alatt, milyen válaszidővel futnak le!

- Tesztadatok generálása
- Java/szerver oldali profilozás
- Hálózaton keresztül történő mérés (JMeter)

Ezek alapján legalábbis javaslatok az optimalizálásra vonatkozóan.

\section*{Összegzés}

% TODO: Ezt elég csak a végén megcsinálni!

\section*{Hivatkozások}

[1]\url{ https://hu.wikipedia.org/wiki/Reszponzív\_weboldal }

[2]\url{ https://hu.wikipedia.org/wiki/Dependency\_injection#cite_note-JamesShore-1 }	
% A 3,4,5 az a [2]-nek a továbbhivatkozása

[3]\url{ http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html }

[4]\url{ http://wiki.c2.com/?HollywoodPrinciple }

[5]\url{ https://martinfowler.com/articles/injection.html }

[6]\url{ https://hu.wikipedia.org/wiki/A_kontroll_megfordítása }

[7]\url{ https://hu.wikipedia.org/wiki/Java_Persistence_API#cite_note-1 }

[8]\url{ https://hu.wikipedia.org/wiki/Java_Database_Connectivity }

[9]\url{ https://stackoverflow.com/questions/10604298/spring-component-versus-bean }

[21]\url{ http://www.rgvi.gtk.szie.hu/system/files/upload/course_material/fesztivalok.pdf }

[22]\url{ https://hu.wikipedia.org/wiki/Hashtag#cite_note-1 }

[23] \url{ https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-system-requirements.html }

[31] \url{ http://nodehun.blogspot.hu/2015/05/mi-az-az-npm.html }

Konkurrens alkalmazások
Java Spring
Angular

\end{document}